{
  "version": 3,
  "sources": ["../bundle-UerOvD/checked-fetch.js", "wrangler-modules-watch:wrangler:modules-watch", "../../../../../../../../../tools/.pnpm-global/5/node_modules/.pnpm/wrangler@3.25.0/node_modules/wrangler/templates/modules-watch-stub.js", "../../../../../node_modules/.pnpm/itty-router@4.0.27/node_modules/src/src/Router.ts", "../../../../../node_modules/.pnpm/@cloudflare+workers-types@4.20240129.0/node_modules/@cloudflare/workers-types/experimental/index.ts", "../../../../Common/Target/Function/Redirect.js", "../../../../Common/Target/Function/Response.js", "../bundle-UerOvD/middleware-loader.entry.ts", "../bundle-UerOvD/middleware-insertion-facade.js", "../../../Target/Variable/Worker.js", "../../../../../../../../../tools/.pnpm-global/5/node_modules/.pnpm/wrangler@3.25.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../../../../../../../tools/.pnpm-global/5/node_modules/.pnpm/wrangler@3.25.0/node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "D:\\Developer\\Application\\CodeEditorLand\\Environment\\NPM\\Ingress\\.wrangler\\tmp\\dev-ojtfID",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t  );\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", null, "/*! *****************************************************************************\nCopyright (c) Cloudflare. All rights reserved.\nCopyright (c) Microsoft Corporation. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n/* eslint-disable */\n// noinspection JSUnusedGlobalSymbols\nexport declare class DOMException extends Error {\n  constructor(message?: string, name?: string);\n  readonly message: string;\n  readonly name: string;\n  readonly code: number;\n  readonly stack: any;\n  static readonly INDEX_SIZE_ERR: number;\n  static readonly DOMSTRING_SIZE_ERR: number;\n  static readonly HIERARCHY_REQUEST_ERR: number;\n  static readonly WRONG_DOCUMENT_ERR: number;\n  static readonly INVALID_CHARACTER_ERR: number;\n  static readonly NO_DATA_ALLOWED_ERR: number;\n  static readonly NO_MODIFICATION_ALLOWED_ERR: number;\n  static readonly NOT_FOUND_ERR: number;\n  static readonly NOT_SUPPORTED_ERR: number;\n  static readonly INUSE_ATTRIBUTE_ERR: number;\n  static readonly INVALID_STATE_ERR: number;\n  static readonly SYNTAX_ERR: number;\n  static readonly INVALID_MODIFICATION_ERR: number;\n  static readonly NAMESPACE_ERR: number;\n  static readonly INVALID_ACCESS_ERR: number;\n  static readonly VALIDATION_ERR: number;\n  static readonly TYPE_MISMATCH_ERR: number;\n  static readonly SECURITY_ERR: number;\n  static readonly NETWORK_ERR: number;\n  static readonly ABORT_ERR: number;\n  static readonly URL_MISMATCH_ERR: number;\n  static readonly QUOTA_EXCEEDED_ERR: number;\n  static readonly TIMEOUT_ERR: number;\n  static readonly INVALID_NODE_TYPE_ERR: number;\n  static readonly DATA_CLONE_ERR: number;\n}\nexport type WorkerGlobalScopeEventMap = {\n  fetch: FetchEvent;\n  scheduled: ScheduledEvent;\n  queue: QueueEvent;\n  unhandledrejection: PromiseRejectionEvent;\n  rejectionhandled: PromiseRejectionEvent;\n};\nexport declare abstract class WorkerGlobalScope extends EventTarget<WorkerGlobalScopeEventMap> {\n  EventTarget: typeof EventTarget;\n}\nexport interface Console {\n  \"assert\"(condition?: boolean, ...data: any[]): void;\n  clear(): void;\n  count(label?: string): void;\n  countReset(label?: string): void;\n  debug(...data: any[]): void;\n  dir(item?: any, options?: any): void;\n  dirxml(...data: any[]): void;\n  error(...data: any[]): void;\n  group(...data: any[]): void;\n  groupCollapsed(...data: any[]): void;\n  groupEnd(): void;\n  info(...data: any[]): void;\n  log(...data: any[]): void;\n  table(tabularData?: any, properties?: string[]): void;\n  time(label?: string): void;\n  timeEnd(label?: string): void;\n  timeLog(label?: string, ...data: any[]): void;\n  timeStamp(label?: string): void;\n  trace(...data: any[]): void;\n  warn(...data: any[]): void;\n}\nexport declare const console: Console;\nexport type BufferSource = ArrayBufferView | ArrayBuffer;\nexport declare namespace WebAssembly {\n  class CompileError extends Error {\n    constructor(message?: string);\n  }\n  class RuntimeError extends Error {\n    constructor(message?: string);\n  }\n  type ValueType =\n    | \"anyfunc\"\n    | \"externref\"\n    | \"f32\"\n    | \"f64\"\n    | \"i32\"\n    | \"i64\"\n    | \"v128\";\n  interface GlobalDescriptor {\n    value: ValueType;\n    mutable?: boolean;\n  }\n  class Global {\n    constructor(descriptor: GlobalDescriptor, value?: any);\n    value: any;\n    valueOf(): any;\n  }\n  type ImportValue = ExportValue | number;\n  type ModuleImports = Record<string, ImportValue>;\n  type Imports = Record<string, ModuleImports>;\n  type ExportValue = Function | Global | Memory | Table;\n  type Exports = Record<string, ExportValue>;\n  class Instance {\n    constructor(module: Module, imports?: Imports);\n    readonly exports: Exports;\n  }\n  interface MemoryDescriptor {\n    initial: number;\n    maximum?: number;\n    shared?: boolean;\n  }\n  class Memory {\n    constructor(descriptor: MemoryDescriptor);\n    readonly buffer: ArrayBuffer;\n    grow(delta: number): number;\n  }\n  type ImportExportKind = \"function\" | \"global\" | \"memory\" | \"table\";\n  interface ModuleExportDescriptor {\n    kind: ImportExportKind;\n    name: string;\n  }\n  interface ModuleImportDescriptor {\n    kind: ImportExportKind;\n    module: string;\n    name: string;\n  }\n  abstract class Module {\n    static customSections(module: Module, sectionName: string): ArrayBuffer[];\n    static exports(module: Module): ModuleExportDescriptor[];\n    static imports(module: Module): ModuleImportDescriptor[];\n  }\n  type TableKind = \"anyfunc\" | \"externref\";\n  interface TableDescriptor {\n    element: TableKind;\n    initial: number;\n    maximum?: number;\n  }\n  class Table {\n    constructor(descriptor: TableDescriptor, value?: any);\n    readonly length: number;\n    get(index: number): any;\n    grow(delta: number, value?: any): number;\n    set(index: number, value?: any): void;\n  }\n  function instantiate(module: Module, imports?: Imports): Promise<Instance>;\n  function validate(bytes: BufferSource): boolean;\n}\n/** This ServiceWorker API interface represents the global execution context of a service worker. */\nexport interface ServiceWorkerGlobalScope extends WorkerGlobalScope {\n  DOMException: typeof DOMException;\n  WorkerGlobalScope: typeof WorkerGlobalScope;\n  btoa(data: string): string;\n  atob(data: string): string;\n  setTimeout(callback: (...args: any[]) => void, msDelay?: number): number;\n  setTimeout<Args extends any[]>(\n    callback: (...args: Args) => void,\n    msDelay?: number,\n    ...args: Args\n  ): number;\n  clearTimeout(timeoutId: number | null): void;\n  setInterval(callback: (...args: any[]) => void, msDelay?: number): number;\n  setInterval<Args extends any[]>(\n    callback: (...args: Args) => void,\n    msDelay?: number,\n    ...args: Args\n  ): number;\n  clearInterval(timeoutId: number | null): void;\n  queueMicrotask(task: Function): void;\n  structuredClone<T>(value: T, options?: StructuredSerializeOptions): T;\n  fetch(\n    input: RequestInfo,\n    init?: RequestInit<RequestInitCfProperties>\n  ): Promise<Response>;\n  self: ServiceWorkerGlobalScope;\n  crypto: Crypto;\n  caches: CacheStorage;\n  scheduler: Scheduler;\n  performance: Performance;\n  readonly origin: string;\n  Event: typeof Event;\n  ExtendableEvent: typeof ExtendableEvent;\n  CustomEvent: typeof CustomEvent;\n  PromiseRejectionEvent: typeof PromiseRejectionEvent;\n  FetchEvent: typeof FetchEvent;\n  TailEvent: typeof TailEvent;\n  TraceEvent: typeof TailEvent;\n  ScheduledEvent: typeof ScheduledEvent;\n  MessageEvent: typeof MessageEvent;\n  CloseEvent: typeof CloseEvent;\n  ReadableStreamDefaultReader: typeof ReadableStreamDefaultReader;\n  ReadableStreamBYOBReader: typeof ReadableStreamBYOBReader;\n  ReadableStream: typeof ReadableStream;\n  WritableStream: typeof WritableStream;\n  WritableStreamDefaultWriter: typeof WritableStreamDefaultWriter;\n  TransformStream: typeof TransformStream;\n  ByteLengthQueuingStrategy: typeof ByteLengthQueuingStrategy;\n  CountQueuingStrategy: typeof CountQueuingStrategy;\n  ReadableStreamBYOBRequest: typeof ReadableStreamBYOBRequest;\n  ReadableStreamDefaultController: typeof ReadableStreamDefaultController;\n  ReadableByteStreamController: typeof ReadableByteStreamController;\n  WritableStreamDefaultController: typeof WritableStreamDefaultController;\n  CompressionStream: typeof CompressionStream;\n  DecompressionStream: typeof DecompressionStream;\n  TextEncoderStream: typeof TextEncoderStream;\n  TextDecoderStream: typeof TextDecoderStream;\n  Headers: typeof Headers;\n  Body: typeof Body;\n  Request: typeof Request;\n  Response: typeof Response;\n  WebSocket: typeof WebSocket;\n  WebSocketPair: typeof WebSocketPair;\n  WebSocketRequestResponsePair: typeof WebSocketRequestResponsePair;\n  AbortController: typeof AbortController;\n  AbortSignal: typeof AbortSignal;\n  TextDecoder: typeof TextDecoder;\n  TextEncoder: typeof TextEncoder;\n  navigator: Navigator;\n  Navigator: typeof Navigator;\n  URL: typeof URL;\n  URLSearchParams: typeof URLSearchParams;\n  URLPattern: typeof URLPattern;\n  Blob: typeof Blob;\n  File: typeof File;\n  FormData: typeof FormData;\n  Crypto: typeof Crypto;\n  SubtleCrypto: typeof SubtleCrypto;\n  CryptoKey: typeof CryptoKey;\n  CacheStorage: typeof CacheStorage;\n  Cache: typeof Cache;\n  FixedLengthStream: typeof FixedLengthStream;\n  IdentityTransformStream: typeof IdentityTransformStream;\n  HTMLRewriter: typeof HTMLRewriter;\n  GPUAdapter: typeof gpuGPUAdapter;\n  GPUOutOfMemoryError: typeof gpuGPUOutOfMemoryError;\n  GPUValidationError: typeof gpuGPUValidationError;\n  GPUInternalError: typeof gpuGPUInternalError;\n  GPUDeviceLostInfo: typeof gpuGPUDeviceLostInfo;\n  GPUBufferUsage: typeof gpuGPUBufferUsage;\n  GPUShaderStage: typeof gpuGPUShaderStage;\n  GPUMapMode: typeof gpuGPUMapMode;\n  GPUTextureUsage: typeof gpuGPUTextureUsage;\n  GPUColorWrite: typeof gpuGPUColorWrite;\n}\nexport declare function addEventListener<\n  Type extends keyof WorkerGlobalScopeEventMap\n>(\n  type: Type,\n  handler: EventListenerOrEventListenerObject<WorkerGlobalScopeEventMap[Type]>,\n  options?: EventTargetAddEventListenerOptions | boolean\n): void;\nexport declare function removeEventListener<\n  Type extends keyof WorkerGlobalScopeEventMap\n>(\n  type: Type,\n  handler: EventListenerOrEventListenerObject<WorkerGlobalScopeEventMap[Type]>,\n  options?: EventTargetEventListenerOptions | boolean\n): void;\n/** Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise. */\nexport declare function dispatchEvent(\n  event: WorkerGlobalScopeEventMap[keyof WorkerGlobalScopeEventMap]\n): boolean;\nexport declare function btoa(data: string): string;\nexport declare function atob(data: string): string;\nexport declare function setTimeout(\n  callback: (...args: any[]) => void,\n  msDelay?: number\n): number;\nexport declare function setTimeout<Args extends any[]>(\n  callback: (...args: Args) => void,\n  msDelay?: number,\n  ...args: Args\n): number;\nexport declare function clearTimeout(timeoutId: number | null): void;\nexport declare function setInterval(\n  callback: (...args: any[]) => void,\n  msDelay?: number\n): number;\nexport declare function setInterval<Args extends any[]>(\n  callback: (...args: Args) => void,\n  msDelay?: number,\n  ...args: Args\n): number;\nexport declare function clearInterval(timeoutId: number | null): void;\nexport declare function queueMicrotask(task: Function): void;\nexport declare function structuredClone<T>(\n  value: T,\n  options?: StructuredSerializeOptions\n): T;\nexport declare function fetch(\n  input: RequestInfo,\n  init?: RequestInit<RequestInitCfProperties>\n): Promise<Response>;\nexport declare const self: ServiceWorkerGlobalScope;\nexport declare const crypto: Crypto;\nexport declare const caches: CacheStorage;\nexport declare const scheduler: Scheduler;\nexport declare const performance: Performance;\nexport declare const origin: string;\nexport declare const navigator: Navigator;\nexport interface TestController {}\nexport interface ExecutionContext {\n  waitUntil(promise: Promise<any>): void;\n  passThroughOnException(): void;\n}\nexport type ExportedHandlerFetchHandler<\n  Env = unknown,\n  CfHostMetadata = unknown\n> = (\n  request: Request<CfHostMetadata, IncomingRequestCfProperties<CfHostMetadata>>,\n  env: Env,\n  ctx: ExecutionContext\n) => Response | Promise<Response>;\nexport type ExportedHandlerTailHandler<Env = unknown> = (\n  events: TraceItem[],\n  env: Env,\n  ctx: ExecutionContext\n) => void | Promise<void>;\nexport type ExportedHandlerTraceHandler<Env = unknown> = (\n  traces: TraceItem[],\n  env: Env,\n  ctx: ExecutionContext\n) => void | Promise<void>;\nexport type ExportedHandlerScheduledHandler<Env = unknown> = (\n  controller: ScheduledController,\n  env: Env,\n  ctx: ExecutionContext\n) => void | Promise<void>;\nexport type ExportedHandlerQueueHandler<Env = unknown, Message = unknown> = (\n  batch: MessageBatch<Message>,\n  env: Env,\n  ctx: ExecutionContext\n) => void | Promise<void>;\nexport type ExportedHandlerTestHandler<Env = unknown> = (\n  controller: TestController,\n  env: Env,\n  ctx: ExecutionContext\n) => void | Promise<void>;\nexport interface ExportedHandler<\n  Env = unknown,\n  QueueHandlerMessage = unknown,\n  CfHostMetadata = unknown\n> {\n  fetch?: ExportedHandlerFetchHandler<Env, CfHostMetadata>;\n  tail?: ExportedHandlerTailHandler<Env>;\n  trace?: ExportedHandlerTraceHandler<Env>;\n  scheduled?: ExportedHandlerScheduledHandler<Env>;\n  test?: ExportedHandlerTestHandler<Env>;\n  email?: EmailExportedHandler<Env>;\n  queue?: ExportedHandlerQueueHandler<Env, QueueHandlerMessage>;\n}\nexport interface StructuredSerializeOptions {\n  transfer?: any[];\n}\nexport declare abstract class PromiseRejectionEvent extends Event {\n  readonly promise: Promise<any>;\n  readonly reason: any;\n}\nexport declare abstract class Navigator {\n  sendBeacon(\n    url: string,\n    body?:\n      | ReadableStream\n      | string\n      | (ArrayBuffer | ArrayBufferView)\n      | Blob\n      | URLSearchParams\n      | FormData\n  ): boolean;\n  readonly userAgent: string;\n  readonly gpu: gpuGPU;\n}\n/** Provides access to performance-related information for the current page. It's part of the High Resolution Time API, but is enhanced by the Performance Timeline API, the Navigation Timing API, the User Timing API, and the Resource Timing API. */\nexport interface Performance {\n  readonly timeOrigin: number;\n  now(): number;\n}\nexport interface DurableObject {\n  fetch(request: Request): Response | Promise<Response>;\n  alarm?(): void | Promise<void>;\n  webSocketMessage?(\n    ws: WebSocket,\n    message: string | ArrayBuffer\n  ): void | Promise<void>;\n  webSocketClose?(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): void | Promise<void>;\n  webSocketError?(ws: WebSocket, error: unknown): void | Promise<void>;\n}\nexport interface DurableObjectStub extends WorkerRpc {\n  readonly id: DurableObjectId;\n  readonly name?: string;\n}\nexport interface DurableObjectId {\n  toString(): string;\n  equals(other: DurableObjectId): boolean;\n  readonly name?: string;\n}\nexport interface DurableObjectNamespace {\n  newUniqueId(\n    options?: DurableObjectNamespaceNewUniqueIdOptions\n  ): DurableObjectId;\n  idFromName(name: string): DurableObjectId;\n  idFromString(id: string): DurableObjectId;\n  get(\n    id: DurableObjectId,\n    options?: DurableObjectNamespaceGetDurableObjectOptions\n  ): DurableObjectStub;\n  getExisting(\n    id: DurableObjectId,\n    options?: DurableObjectNamespaceGetDurableObjectOptions\n  ): DurableObjectStub;\n  jurisdiction(jurisdiction: DurableObjectJurisdiction): DurableObjectNamespace;\n}\nexport type DurableObjectJurisdiction = \"eu\" | \"fedramp\";\nexport interface DurableObjectNamespaceNewUniqueIdOptions {\n  jurisdiction?: DurableObjectJurisdiction;\n}\nexport type DurableObjectLocationHint =\n  | \"wnam\"\n  | \"enam\"\n  | \"sam\"\n  | \"weur\"\n  | \"eeur\"\n  | \"apac\"\n  | \"oc\"\n  | \"afr\"\n  | \"me\";\nexport interface DurableObjectNamespaceGetDurableObjectOptions {\n  locationHint?: DurableObjectLocationHint;\n}\nexport interface DurableObjectState {\n  waitUntil(promise: Promise<any>): void;\n  readonly id: DurableObjectId;\n  readonly storage: DurableObjectStorage;\n  blockConcurrencyWhile<T>(callback: () => Promise<T>): Promise<T>;\n  acceptWebSocket(ws: WebSocket, tags?: string[]): void;\n  getWebSockets(tag?: string): WebSocket[];\n  setWebSocketAutoResponse(maybeReqResp?: WebSocketRequestResponsePair): void;\n  getWebSocketAutoResponse(): WebSocketRequestResponsePair | null;\n  getWebSocketAutoResponseTimestamp(ws: WebSocket): Date | null;\n  setHibernatableWebSocketEventTimeout(timeoutMs?: number): void;\n  getHibernatableWebSocketEventTimeout(): number | null;\n  getTags(ws: WebSocket): string[];\n  abort(reason?: string): void;\n}\nexport interface DurableObjectTransaction {\n  get<T = unknown>(\n    key: string,\n    options?: DurableObjectGetOptions\n  ): Promise<T | undefined>;\n  get<T = unknown>(\n    keys: string[],\n    options?: DurableObjectGetOptions\n  ): Promise<Map<string, T>>;\n  list<T = unknown>(\n    options?: DurableObjectListOptions\n  ): Promise<Map<string, T>>;\n  put<T>(\n    key: string,\n    value: T,\n    options?: DurableObjectPutOptions\n  ): Promise<void>;\n  put<T>(\n    entries: Record<string, T>,\n    options?: DurableObjectPutOptions\n  ): Promise<void>;\n  delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;\n  delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;\n  rollback(): void;\n  getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;\n  setAlarm(\n    scheduledTime: number | Date,\n    options?: DurableObjectSetAlarmOptions\n  ): Promise<void>;\n  deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;\n}\nexport interface DurableObjectStorage {\n  get<T = unknown>(\n    key: string,\n    options?: DurableObjectGetOptions\n  ): Promise<T | undefined>;\n  get<T = unknown>(\n    keys: string[],\n    options?: DurableObjectGetOptions\n  ): Promise<Map<string, T>>;\n  list<T = unknown>(\n    options?: DurableObjectListOptions\n  ): Promise<Map<string, T>>;\n  put<T>(\n    key: string,\n    value: T,\n    options?: DurableObjectPutOptions\n  ): Promise<void>;\n  put<T>(\n    entries: Record<string, T>,\n    options?: DurableObjectPutOptions\n  ): Promise<void>;\n  delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;\n  delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;\n  deleteAll(options?: DurableObjectPutOptions): Promise<void>;\n  transaction<T>(\n    closure: (txn: DurableObjectTransaction) => Promise<T>\n  ): Promise<T>;\n  getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;\n  setAlarm(\n    scheduledTime: number | Date,\n    options?: DurableObjectSetAlarmOptions\n  ): Promise<void>;\n  deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;\n  sync(): Promise<void>;\n  sql: SqlStorage;\n  transactionSync<T>(closure: () => T): T;\n  getCurrentBookmark(): Promise<string>;\n  getBookmarkForTime(timestamp: number | Date): Promise<string>;\n  onNextSessionRestoreBookmark(bookmark: string): Promise<string>;\n}\nexport interface DurableObjectListOptions {\n  start?: string;\n  startAfter?: string;\n  end?: string;\n  prefix?: string;\n  reverse?: boolean;\n  limit?: number;\n  allowConcurrency?: boolean;\n  noCache?: boolean;\n}\nexport interface DurableObjectGetOptions {\n  allowConcurrency?: boolean;\n  noCache?: boolean;\n}\nexport interface DurableObjectGetAlarmOptions {\n  allowConcurrency?: boolean;\n}\nexport interface DurableObjectPutOptions {\n  allowConcurrency?: boolean;\n  allowUnconfirmed?: boolean;\n  noCache?: boolean;\n}\nexport interface DurableObjectSetAlarmOptions {\n  allowConcurrency?: boolean;\n  allowUnconfirmed?: boolean;\n}\nexport declare class WebSocketRequestResponsePair {\n  constructor(request: string, response: string);\n  get request(): string;\n  get response(): string;\n}\nexport interface AnalyticsEngineDataset {\n  writeDataPoint(event?: AnalyticsEngineDataPoint): void;\n}\nexport interface AnalyticsEngineDataPoint {\n  indexes?: ((ArrayBuffer | string) | null)[];\n  doubles?: number[];\n  blobs?: ((ArrayBuffer | string) | null)[];\n}\nexport declare class Event {\n  constructor(type: string, init?: EventInit);\n  get type(): string;\n  get eventPhase(): number;\n  get composed(): boolean;\n  get bubbles(): boolean;\n  get cancelable(): boolean;\n  get defaultPrevented(): boolean;\n  get returnValue(): boolean;\n  get currentTarget(): EventTarget | undefined;\n  get srcElement(): EventTarget | undefined;\n  get timeStamp(): number;\n  get isTrusted(): boolean;\n  get cancelBubble(): boolean;\n  set cancelBubble(value: boolean);\n  stopImmediatePropagation(): void;\n  preventDefault(): void;\n  stopPropagation(): void;\n  composedPath(): EventTarget[];\n  static readonly NONE: number;\n  static readonly CAPTURING_PHASE: number;\n  static readonly AT_TARGET: number;\n  static readonly BUBBLING_PHASE: number;\n}\nexport interface EventInit {\n  bubbles?: boolean;\n  cancelable?: boolean;\n  composed?: boolean;\n}\nexport type EventListener<EventType extends Event = Event> = (\n  event: EventType\n) => void;\nexport interface EventListenerObject<EventType extends Event = Event> {\n  handleEvent(event: EventType): void;\n}\nexport type EventListenerOrEventListenerObject<\n  EventType extends Event = Event\n> = EventListener<EventType> | EventListenerObject<EventType>;\nexport declare class EventTarget<\n  EventMap extends Record<string, Event> = Record<string, Event>\n> {\n  constructor();\n  addEventListener<Type extends keyof EventMap>(\n    type: Type,\n    handler: EventListenerOrEventListenerObject<EventMap[Type]>,\n    options?: EventTargetAddEventListenerOptions | boolean\n  ): void;\n  removeEventListener<Type extends keyof EventMap>(\n    type: Type,\n    handler: EventListenerOrEventListenerObject<EventMap[Type]>,\n    options?: EventTargetEventListenerOptions | boolean\n  ): void;\n  dispatchEvent(event: EventMap[keyof EventMap]): boolean;\n}\nexport interface EventTargetEventListenerOptions {\n  capture?: boolean;\n}\nexport interface EventTargetAddEventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n  signal?: AbortSignal;\n}\nexport interface EventTargetHandlerObject {\n  handleEvent: (event: Event) => any | undefined;\n}\nexport declare class AbortController {\n  constructor();\n  get signal(): AbortSignal;\n  abort(reason?: any): void;\n}\nexport declare abstract class AbortSignal extends EventTarget {\n  static abort(reason?: any): AbortSignal;\n  static timeout(delay: number): AbortSignal;\n  static any(signals: AbortSignal[]): AbortSignal;\n  get aborted(): boolean;\n  get reason(): any;\n  throwIfAborted(): void;\n}\nexport interface Scheduler {\n  wait(delay: number, maybeOptions?: SchedulerWaitOptions): Promise<void>;\n}\nexport interface SchedulerWaitOptions {\n  signal?: AbortSignal;\n}\nexport declare abstract class ExtendableEvent extends Event {\n  waitUntil(promise: Promise<any>): void;\n}\nexport declare class CustomEvent extends Event {\n  constructor(type: string, init?: CustomEventCustomEventInit);\n  get detail(): any | undefined;\n}\nexport interface CustomEventCustomEventInit {\n  bubbles?: boolean;\n  cancelable?: boolean;\n  composed?: boolean;\n  detail?: any;\n}\nexport declare class Blob {\n  constructor(\n    bits?: ((ArrayBuffer | ArrayBufferView) | string | Blob)[],\n    options?: BlobOptions\n  );\n  get size(): number;\n  get type(): string;\n  slice(start?: number, end?: number, type?: string): Blob;\n  arrayBuffer(): Promise<ArrayBuffer>;\n  text(): Promise<string>;\n  stream(): ReadableStream;\n}\nexport interface BlobOptions {\n  type?: string;\n}\nexport declare class File extends Blob {\n  constructor(\n    bits: ((ArrayBuffer | ArrayBufferView) | string | Blob)[] | undefined,\n    name: string,\n    options?: FileOptions\n  );\n  get name(): string;\n  get lastModified(): number;\n}\nexport interface FileOptions {\n  type?: string;\n  lastModified?: number;\n}\nexport declare abstract class CacheStorage {\n  open(cacheName: string): Promise<Cache>;\n  readonly default: Cache;\n}\nexport declare abstract class Cache {\n  delete(request: RequestInfo, options?: CacheQueryOptions): Promise<boolean>;\n  match(\n    request: RequestInfo,\n    options?: CacheQueryOptions\n  ): Promise<Response | undefined>;\n  put(request: RequestInfo, response: Response): Promise<void>;\n}\nexport interface CacheQueryOptions {\n  ignoreMethod?: boolean;\n}\nexport declare abstract class Crypto {\n  get subtle(): SubtleCrypto;\n  getRandomValues<\n    T extends\n      | Int8Array\n      | Uint8Array\n      | Int16Array\n      | Uint16Array\n      | Int32Array\n      | Uint32Array\n      | BigInt64Array\n      | BigUint64Array\n  >(buffer: T): T;\n  randomUUID(): string;\n  DigestStream: typeof DigestStream;\n}\nexport declare abstract class SubtleCrypto {\n  encrypt(\n    algorithm: string | SubtleCryptoEncryptAlgorithm,\n    key: CryptoKey,\n    plainText: ArrayBuffer | ArrayBufferView\n  ): Promise<ArrayBuffer>;\n  decrypt(\n    algorithm: string | SubtleCryptoEncryptAlgorithm,\n    key: CryptoKey,\n    cipherText: ArrayBuffer | ArrayBufferView\n  ): Promise<ArrayBuffer>;\n  sign(\n    algorithm: string | SubtleCryptoSignAlgorithm,\n    key: CryptoKey,\n    data: ArrayBuffer | ArrayBufferView\n  ): Promise<ArrayBuffer>;\n  verify(\n    algorithm: string | SubtleCryptoSignAlgorithm,\n    key: CryptoKey,\n    signature: ArrayBuffer | ArrayBufferView,\n    data: ArrayBuffer | ArrayBufferView\n  ): Promise<boolean>;\n  digest(\n    algorithm: string | SubtleCryptoHashAlgorithm,\n    data: ArrayBuffer | ArrayBufferView\n  ): Promise<ArrayBuffer>;\n  generateKey(\n    algorithm: string | SubtleCryptoGenerateKeyAlgorithm,\n    extractable: boolean,\n    keyUsages: string[]\n  ): Promise<CryptoKey | CryptoKeyPair>;\n  deriveKey(\n    algorithm: string | SubtleCryptoDeriveKeyAlgorithm,\n    baseKey: CryptoKey,\n    derivedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm,\n    extractable: boolean,\n    keyUsages: string[]\n  ): Promise<CryptoKey>;\n  deriveBits(\n    algorithm: string | SubtleCryptoDeriveKeyAlgorithm,\n    baseKey: CryptoKey,\n    length: number | null\n  ): Promise<ArrayBuffer>;\n  importKey(\n    format: string,\n    keyData: (ArrayBuffer | ArrayBufferView) | JsonWebKey,\n    algorithm: string | SubtleCryptoImportKeyAlgorithm,\n    extractable: boolean,\n    keyUsages: string[]\n  ): Promise<CryptoKey>;\n  exportKey(format: string, key: CryptoKey): Promise<ArrayBuffer | JsonWebKey>;\n  wrapKey(\n    format: string,\n    key: CryptoKey,\n    wrappingKey: CryptoKey,\n    wrapAlgorithm: string | SubtleCryptoEncryptAlgorithm\n  ): Promise<ArrayBuffer>;\n  unwrapKey(\n    format: string,\n    wrappedKey: ArrayBuffer | ArrayBufferView,\n    unwrappingKey: CryptoKey,\n    unwrapAlgorithm: string | SubtleCryptoEncryptAlgorithm,\n    unwrappedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm,\n    extractable: boolean,\n    keyUsages: string[]\n  ): Promise<CryptoKey>;\n  timingSafeEqual(\n    a: ArrayBuffer | ArrayBufferView,\n    b: ArrayBuffer | ArrayBufferView\n  ): boolean;\n}\nexport declare abstract class CryptoKey {\n  readonly type: string;\n  readonly extractable: boolean;\n  readonly algorithm:\n    | CryptoKeyKeyAlgorithm\n    | CryptoKeyAesKeyAlgorithm\n    | CryptoKeyHmacKeyAlgorithm\n    | CryptoKeyRsaKeyAlgorithm\n    | CryptoKeyEllipticKeyAlgorithm\n    | CryptoKeyArbitraryKeyAlgorithm;\n  readonly usages: string[];\n}\nexport interface CryptoKeyPair {\n  publicKey: CryptoKey;\n  privateKey: CryptoKey;\n}\nexport interface JsonWebKey {\n  kty: string;\n  use?: string;\n  key_ops?: string[];\n  alg?: string;\n  ext?: boolean;\n  crv?: string;\n  x?: string;\n  y?: string;\n  d?: string;\n  n?: string;\n  e?: string;\n  p?: string;\n  q?: string;\n  dp?: string;\n  dq?: string;\n  qi?: string;\n  oth?: RsaOtherPrimesInfo[];\n  k?: string;\n}\nexport interface RsaOtherPrimesInfo {\n  r?: string;\n  d?: string;\n  t?: string;\n}\nexport interface SubtleCryptoDeriveKeyAlgorithm {\n  name: string;\n  salt?: ArrayBuffer;\n  iterations?: number;\n  hash?: string | SubtleCryptoHashAlgorithm;\n  $public?: CryptoKey;\n  info?: ArrayBuffer;\n}\nexport interface SubtleCryptoEncryptAlgorithm {\n  name: string;\n  iv?: ArrayBuffer;\n  additionalData?: ArrayBuffer;\n  tagLength?: number;\n  counter?: ArrayBuffer;\n  length?: number;\n  label?: ArrayBuffer;\n}\nexport interface SubtleCryptoGenerateKeyAlgorithm {\n  name: string;\n  hash?: string | SubtleCryptoHashAlgorithm;\n  modulusLength?: number;\n  publicExponent?: ArrayBuffer;\n  length?: number;\n  namedCurve?: string;\n}\nexport interface SubtleCryptoHashAlgorithm {\n  name: string;\n}\nexport interface SubtleCryptoImportKeyAlgorithm {\n  name: string;\n  hash?: string | SubtleCryptoHashAlgorithm;\n  length?: number;\n  namedCurve?: string;\n  compressed?: boolean;\n}\nexport interface SubtleCryptoSignAlgorithm {\n  name: string;\n  hash?: string | SubtleCryptoHashAlgorithm;\n  dataLength?: number;\n  saltLength?: number;\n}\nexport interface CryptoKeyKeyAlgorithm {\n  name: string;\n}\nexport interface CryptoKeyAesKeyAlgorithm {\n  name: string;\n  length: number;\n}\nexport interface CryptoKeyHmacKeyAlgorithm {\n  name: string;\n  hash: CryptoKeyKeyAlgorithm;\n  length: number;\n}\nexport interface CryptoKeyRsaKeyAlgorithm {\n  name: string;\n  modulusLength: number;\n  publicExponent: ArrayBuffer | (ArrayBuffer | ArrayBufferView);\n  hash?: CryptoKeyKeyAlgorithm;\n}\nexport interface CryptoKeyEllipticKeyAlgorithm {\n  name: string;\n  namedCurve: string;\n}\nexport interface CryptoKeyArbitraryKeyAlgorithm {\n  name: string;\n  hash?: CryptoKeyKeyAlgorithm;\n  namedCurve?: string;\n  length?: number;\n}\nexport declare class DigestStream extends WritableStream<\n  ArrayBuffer | ArrayBufferView\n> {\n  constructor(algorithm: string | SubtleCryptoHashAlgorithm);\n  get digest(): Promise<ArrayBuffer>;\n}\nexport declare class TextDecoder {\n  constructor(decoder?: string, options?: TextDecoderConstructorOptions);\n  decode(\n    input?: ArrayBuffer | ArrayBufferView,\n    options?: TextDecoderDecodeOptions\n  ): string;\n  get encoding(): string;\n  get fatal(): boolean;\n  get ignoreBOM(): boolean;\n}\nexport declare class TextEncoder {\n  constructor();\n  encode(input?: string): Uint8Array;\n  encodeInto(\n    input: string,\n    buffer: ArrayBuffer | ArrayBufferView\n  ): TextEncoderEncodeIntoResult;\n  get encoding(): string;\n}\nexport interface TextDecoderConstructorOptions {\n  fatal: boolean;\n  ignoreBOM: boolean;\n}\nexport interface TextDecoderDecodeOptions {\n  stream: boolean;\n}\nexport interface TextEncoderEncodeIntoResult {\n  read: number;\n  written: number;\n}\nexport declare class FormData {\n  constructor();\n  append(name: string, value: string): void;\n  append(name: string, value: Blob, filename?: string): void;\n  delete(name: string): void;\n  get(name: string): (File | string) | null;\n  getAll(name: string): (File | string)[];\n  has(name: string): boolean;\n  set(name: string, value: string): void;\n  set(name: string, value: Blob, filename?: string): void;\n  entries(): IterableIterator<[key: string, value: File | string]>;\n  keys(): IterableIterator<string>;\n  values(): IterableIterator<File | string>;\n  forEach<This = unknown>(\n    callback: (\n      this: This,\n      value: File | string,\n      key: string,\n      parent: FormData\n    ) => void,\n    thisArg?: This\n  ): void;\n  [Symbol.iterator](): IterableIterator<[key: string, value: File | string]>;\n}\nexport interface ContentOptions {\n  html?: boolean;\n}\nexport declare class HTMLRewriter {\n  constructor();\n  on(\n    selector: string,\n    handlers: HTMLRewriterElementContentHandlers\n  ): HTMLRewriter;\n  onDocument(handlers: HTMLRewriterDocumentContentHandlers): HTMLRewriter;\n  transform(response: Response): Response;\n}\nexport interface HTMLRewriterElementContentHandlers {\n  element?(element: Element): void | Promise<void>;\n  comments?(comment: Comment): void | Promise<void>;\n  text?(element: Text): void | Promise<void>;\n}\nexport interface HTMLRewriterDocumentContentHandlers {\n  doctype?(doctype: Doctype): void | Promise<void>;\n  comments?(comment: Comment): void | Promise<void>;\n  text?(text: Text): void | Promise<void>;\n  end?(end: DocumentEnd): void | Promise<void>;\n}\nexport interface Doctype {\n  readonly name: string | null;\n  readonly publicId: string | null;\n  readonly systemId: string | null;\n}\nexport interface Element {\n  tagName: string;\n  readonly attributes: IterableIterator<string[]>;\n  readonly removed: boolean;\n  readonly namespaceURI: string;\n  getAttribute(name: string): string | null;\n  hasAttribute(name: string): boolean;\n  setAttribute(name: string, value: string): Element;\n  removeAttribute(name: string): Element;\n  before(content: string, options?: ContentOptions): Element;\n  after(content: string, options?: ContentOptions): Element;\n  prepend(content: string, options?: ContentOptions): Element;\n  append(content: string, options?: ContentOptions): Element;\n  replace(content: string, options?: ContentOptions): Element;\n  remove(): Element;\n  removeAndKeepContent(): Element;\n  setInnerContent(content: string, options?: ContentOptions): Element;\n  onEndTag(handler: (tag: EndTag) => void | Promise<void>): void;\n}\nexport interface EndTag {\n  name: string;\n  before(content: string, options?: ContentOptions): EndTag;\n  after(content: string, options?: ContentOptions): EndTag;\n  remove(): EndTag;\n}\nexport interface Comment {\n  text: string;\n  readonly removed: boolean;\n  before(content: string, options?: ContentOptions): Comment;\n  after(content: string, options?: ContentOptions): Comment;\n  replace(content: string, options?: ContentOptions): Comment;\n  remove(): Comment;\n}\nexport interface Text {\n  readonly text: string;\n  readonly lastInTextNode: boolean;\n  readonly removed: boolean;\n  before(content: string, options?: ContentOptions): Text;\n  after(content: string, options?: ContentOptions): Text;\n  replace(content: string, options?: ContentOptions): Text;\n  remove(): Text;\n}\nexport interface DocumentEnd {\n  append(content: string, options?: ContentOptions): DocumentEnd;\n}\nexport declare abstract class FetchEvent extends ExtendableEvent {\n  readonly request: Request;\n  respondWith(promise: Response | Promise<Response>): void;\n  passThroughOnException(): void;\n}\nexport type HeadersInit =\n  | Headers\n  | Iterable<Iterable<string>>\n  | Record<string, string>;\nexport declare class Headers {\n  constructor(init?: HeadersInit);\n  get(name: string): string | null;\n  getAll(name: string): string[];\n  getSetCookie(): string[];\n  has(name: string): boolean;\n  set(name: string, value: string): void;\n  append(name: string, value: string): void;\n  delete(name: string): void;\n  forEach<This = unknown>(\n    callback: (this: This, value: string, key: string, parent: Headers) => void,\n    thisArg?: This\n  ): void;\n  entries(): IterableIterator<[key: string, value: string]>;\n  keys(): IterableIterator<string>;\n  values(): IterableIterator<string>;\n  [Symbol.iterator](): IterableIterator<[key: string, value: string]>;\n}\nexport type BodyInit =\n  | ReadableStream<Uint8Array>\n  | string\n  | ArrayBuffer\n  | ArrayBufferView\n  | Blob\n  | URLSearchParams\n  | FormData;\nexport declare abstract class Body {\n  get body(): ReadableStream | null;\n  get bodyUsed(): boolean;\n  arrayBuffer(): Promise<ArrayBuffer>;\n  text(): Promise<string>;\n  json<T>(): Promise<T>;\n  formData(): Promise<FormData>;\n  blob(): Promise<Blob>;\n}\nexport declare class Response extends Body {\n  constructor(body?: BodyInit | null, init?: ResponseInit);\n  static redirect(url: string, status?: number): Response;\n  static json(any: any, maybeInit?: ResponseInit | Response): Response;\n  clone(): Response;\n  get status(): number;\n  get statusText(): string;\n  get headers(): Headers;\n  get ok(): boolean;\n  get redirected(): boolean;\n  get url(): string;\n  get webSocket(): WebSocket | null;\n  get cf(): any | undefined;\n}\nexport interface ResponseInit {\n  status?: number;\n  statusText?: string;\n  headers?: HeadersInit;\n  cf?: any;\n  webSocket?: WebSocket | null;\n  encodeBody?: \"automatic\" | \"manual\";\n}\nexport type RequestInfo<\n  CfHostMetadata = unknown,\n  Cf = CfProperties<CfHostMetadata>\n> = Request<CfHostMetadata, Cf> | string | URL;\nexport declare class Request<\n  CfHostMetadata = unknown,\n  Cf = CfProperties<CfHostMetadata>\n> extends Body {\n  constructor(input: RequestInfo<CfProperties>, init?: RequestInit<Cf>);\n  clone(): Request<CfHostMetadata, Cf>;\n  get method(): string;\n  get url(): string;\n  get headers(): Headers;\n  get redirect(): string;\n  get fetcher(): Fetcher | null;\n  get signal(): AbortSignal;\n  get cf(): Cf | undefined;\n  get integrity(): string;\n  get keepalive(): boolean;\n}\nexport interface RequestInit<Cf = CfProperties> {\n  /** A string to set request's method. */\n  method?: string;\n  /** A Headers object, an object literal, or an array of two-item arrays to set request's headers. */\n  headers?: HeadersInit;\n  /** A BodyInit object or null to set request's body. */\n  body?: BodyInit | null;\n  /** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */\n  redirect?: string;\n  fetcher?: Fetcher | null;\n  cf?: Cf;\n  /** A cryptographic hash of the resource to be fetched by request. Sets request's integrity. */\n  integrity?: string;\n  /** An AbortSignal to set request's signal. */\n  signal?: AbortSignal | null;\n}\nexport declare abstract class Fetcher {\n  fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\n  connect(address: SocketAddress | string, options?: SocketOptions): Socket;\n  queue(\n    queueName: string,\n    messages: ServiceBindingQueueMessage[]\n  ): Promise<FetcherQueueResult>;\n  scheduled(options?: FetcherScheduledOptions): Promise<FetcherScheduledResult>;\n}\nexport interface FetcherPutOptions {\n  expiration?: number;\n  expirationTtl?: number;\n}\nexport interface FetcherScheduledOptions {\n  scheduledTime?: Date;\n  cron?: string;\n}\nexport interface FetcherScheduledResult {\n  outcome: string;\n  noRetry: boolean;\n}\nexport interface FetcherQueueResult {\n  outcome: string;\n  retryAll: boolean;\n  ackAll: boolean;\n  explicitRetries: string[];\n  explicitAcks: string[];\n}\nexport type ServiceBindingQueueMessage<Body = unknown> = {\n  id: string;\n  timestamp: Date;\n} & (\n  | {\n      body: Body;\n    }\n  | {\n      serializedBody: ArrayBuffer | ArrayBufferView;\n    }\n);\nexport interface KVNamespaceListKey<Metadata, Key extends string = string> {\n  name: Key;\n  expiration?: number;\n  metadata?: Metadata;\n}\nexport type KVNamespaceListResult<Metadata, Key extends string = string> =\n  | {\n      list_complete: false;\n      keys: KVNamespaceListKey<Metadata, Key>[];\n      cursor: string;\n      cacheStatus: string | null;\n    }\n  | {\n      list_complete: true;\n      keys: KVNamespaceListKey<Metadata, Key>[];\n      cacheStatus: string | null;\n    };\nexport interface KVNamespace<Key extends string = string> {\n  get(\n    key: Key,\n    options?: Partial<KVNamespaceGetOptions<undefined>>\n  ): Promise<string | null>;\n  get(key: Key, type: \"text\"): Promise<string | null>;\n  get<ExpectedValue = unknown>(\n    key: Key,\n    type: \"json\"\n  ): Promise<ExpectedValue | null>;\n  get(key: Key, type: \"arrayBuffer\"): Promise<ArrayBuffer | null>;\n  get(key: Key, type: \"stream\"): Promise<ReadableStream | null>;\n  get(\n    key: Key,\n    options?: KVNamespaceGetOptions<\"text\">\n  ): Promise<string | null>;\n  get<ExpectedValue = unknown>(\n    key: Key,\n    options?: KVNamespaceGetOptions<\"json\">\n  ): Promise<ExpectedValue | null>;\n  get(\n    key: Key,\n    options?: KVNamespaceGetOptions<\"arrayBuffer\">\n  ): Promise<ArrayBuffer | null>;\n  get(\n    key: Key,\n    options?: KVNamespaceGetOptions<\"stream\">\n  ): Promise<ReadableStream | null>;\n  list<Metadata = unknown>(\n    options?: KVNamespaceListOptions\n  ): Promise<KVNamespaceListResult<Metadata, Key>>;\n  put(\n    key: Key,\n    value: string | ArrayBuffer | ArrayBufferView | ReadableStream,\n    options?: KVNamespacePutOptions\n  ): Promise<void>;\n  getWithMetadata<Metadata = unknown>(\n    key: Key,\n    options?: Partial<KVNamespaceGetOptions<undefined>>\n  ): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;\n  getWithMetadata<Metadata = unknown>(\n    key: Key,\n    type: \"text\"\n  ): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;\n  getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(\n    key: Key,\n    type: \"json\"\n  ): Promise<KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>;\n  getWithMetadata<Metadata = unknown>(\n    key: Key,\n    type: \"arrayBuffer\"\n  ): Promise<KVNamespaceGetWithMetadataResult<ArrayBuffer, Metadata>>;\n  getWithMetadata<Metadata = unknown>(\n    key: Key,\n    type: \"stream\"\n  ): Promise<KVNamespaceGetWithMetadataResult<ReadableStream, Metadata>>;\n  getWithMetadata<Metadata = unknown>(\n    key: Key,\n    options: KVNamespaceGetOptions<\"text\">\n  ): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;\n  getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(\n    key: Key,\n    options: KVNamespaceGetOptions<\"json\">\n  ): Promise<KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>;\n  getWithMetadata<Metadata = unknown>(\n    key: Key,\n    options: KVNamespaceGetOptions<\"arrayBuffer\">\n  ): Promise<KVNamespaceGetWithMetadataResult<ArrayBuffer, Metadata>>;\n  getWithMetadata<Metadata = unknown>(\n    key: Key,\n    options: KVNamespaceGetOptions<\"stream\">\n  ): Promise<KVNamespaceGetWithMetadataResult<ReadableStream, Metadata>>;\n  delete(key: Key): Promise<void>;\n}\nexport interface KVNamespaceListOptions {\n  limit?: number;\n  prefix?: string | null;\n  cursor?: string | null;\n}\nexport interface KVNamespaceGetOptions<Type> {\n  type: Type;\n  cacheTtl?: number;\n}\nexport interface KVNamespacePutOptions {\n  expiration?: number;\n  expirationTtl?: number;\n  metadata?: any | null;\n}\nexport interface KVNamespaceGetWithMetadataResult<Value, Metadata> {\n  value: Value | null;\n  metadata: Metadata | null;\n  cacheStatus: string | null;\n}\nexport type QueueContentType = \"text\" | \"bytes\" | \"json\" | \"v8\";\nexport interface Queue<Body = unknown> {\n  send(message: Body, options?: QueueSendOptions): Promise<void>;\n  sendBatch(messages: Iterable<MessageSendRequest<Body>>): Promise<void>;\n}\nexport interface QueueSendOptions {\n  contentType?: QueueContentType;\n}\nexport interface MessageSendRequest<Body = unknown> {\n  body: Body;\n  contentType?: QueueContentType;\n}\nexport interface Message<Body = unknown> {\n  readonly id: string;\n  readonly timestamp: Date;\n  readonly body: Body;\n  retry(): void;\n  ack(): void;\n}\nexport interface QueueEvent<Body = unknown> extends ExtendableEvent {\n  readonly messages: readonly Message<Body>[];\n  readonly queue: string;\n  retryAll(): void;\n  ackAll(): void;\n}\nexport interface MessageBatch<Body = unknown> {\n  readonly messages: readonly Message<Body>[];\n  readonly queue: string;\n  retryAll(): void;\n  ackAll(): void;\n}\nexport interface R2Error extends Error {\n  readonly name: string;\n  readonly code: number;\n  readonly message: string;\n  readonly action: string;\n  readonly stack: any;\n}\nexport interface R2ListOptions {\n  limit?: number;\n  prefix?: string;\n  cursor?: string;\n  delimiter?: string;\n  startAfter?: string;\n  include?: (\"httpMetadata\" | \"customMetadata\")[];\n}\nexport declare abstract class R2Bucket {\n  head(key: string): Promise<R2Object | null>;\n  get(\n    key: string,\n    options: R2GetOptions & {\n      onlyIf: R2Conditional | Headers;\n    }\n  ): Promise<R2ObjectBody | R2Object | null>;\n  get(key: string, options?: R2GetOptions): Promise<R2ObjectBody | null>;\n  put(\n    key: string,\n    value:\n      | ReadableStream\n      | ArrayBuffer\n      | ArrayBufferView\n      | string\n      | null\n      | Blob,\n    options?: R2PutOptions & {\n      onlyIf: R2Conditional | Headers;\n    }\n  ): Promise<R2Object | null>;\n  put(\n    key: string,\n    value:\n      | ReadableStream\n      | ArrayBuffer\n      | ArrayBufferView\n      | string\n      | null\n      | Blob,\n    options?: R2PutOptions\n  ): Promise<R2Object>;\n  createMultipartUpload(\n    key: string,\n    options?: R2MultipartOptions\n  ): Promise<R2MultipartUpload>;\n  resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;\n  delete(keys: string | string[]): Promise<void>;\n  list(options?: R2ListOptions): Promise<R2Objects>;\n}\nexport interface R2MultipartUpload {\n  readonly key: string;\n  readonly uploadId: string;\n  uploadPart(\n    partNumber: number,\n    value: ReadableStream | (ArrayBuffer | ArrayBufferView) | string | Blob\n  ): Promise<R2UploadedPart>;\n  abort(): Promise<void>;\n  complete(uploadedParts: R2UploadedPart[]): Promise<R2Object>;\n}\nexport interface R2UploadedPart {\n  partNumber: number;\n  etag: string;\n}\nexport declare abstract class R2Object {\n  readonly key: string;\n  readonly version: string;\n  readonly size: number;\n  readonly etag: string;\n  readonly httpEtag: string;\n  readonly checksums: R2Checksums;\n  readonly uploaded: Date;\n  readonly httpMetadata?: R2HTTPMetadata;\n  readonly customMetadata?: Record<string, string>;\n  readonly range?: R2Range;\n  writeHttpMetadata(headers: Headers): void;\n}\nexport interface R2ObjectBody extends R2Object {\n  get body(): ReadableStream;\n  get bodyUsed(): boolean;\n  arrayBuffer(): Promise<ArrayBuffer>;\n  text(): Promise<string>;\n  json<T>(): Promise<T>;\n  blob(): Promise<Blob>;\n}\nexport type R2Range =\n  | {\n      offset: number;\n      length?: number;\n    }\n  | {\n      offset?: number;\n      length: number;\n    }\n  | {\n      suffix: number;\n    };\nexport interface R2Conditional {\n  etagMatches?: string;\n  etagDoesNotMatch?: string;\n  uploadedBefore?: Date;\n  uploadedAfter?: Date;\n  secondsGranularity?: boolean;\n}\nexport interface R2GetOptions {\n  onlyIf?: R2Conditional | Headers;\n  range?: R2Range | Headers;\n}\nexport interface R2PutOptions {\n  onlyIf?: R2Conditional | Headers;\n  httpMetadata?: R2HTTPMetadata | Headers;\n  customMetadata?: Record<string, string>;\n  md5?: ArrayBuffer | string;\n  sha1?: ArrayBuffer | string;\n  sha256?: ArrayBuffer | string;\n  sha384?: ArrayBuffer | string;\n  sha512?: ArrayBuffer | string;\n}\nexport interface R2MultipartOptions {\n  httpMetadata?: R2HTTPMetadata | Headers;\n  customMetadata?: Record<string, string>;\n}\nexport interface R2Checksums {\n  readonly md5?: ArrayBuffer;\n  readonly sha1?: ArrayBuffer;\n  readonly sha256?: ArrayBuffer;\n  readonly sha384?: ArrayBuffer;\n  readonly sha512?: ArrayBuffer;\n  toJSON(): R2StringChecksums;\n}\nexport interface R2StringChecksums {\n  md5?: string;\n  sha1?: string;\n  sha256?: string;\n  sha384?: string;\n  sha512?: string;\n}\nexport interface R2HTTPMetadata {\n  contentType?: string;\n  contentLanguage?: string;\n  contentDisposition?: string;\n  contentEncoding?: string;\n  cacheControl?: string;\n  cacheExpiry?: Date;\n}\nexport type R2Objects = {\n  objects: R2Object[];\n  delimitedPrefixes: string[];\n} & (\n  | {\n      truncated: true;\n      cursor: string;\n    }\n  | {\n      truncated: false;\n    }\n);\nexport declare abstract class WorkerRpc extends Fetcher {}\nexport declare abstract class ScheduledEvent extends ExtendableEvent {\n  readonly scheduledTime: number;\n  readonly cron: string;\n  noRetry(): void;\n}\nexport interface ScheduledController {\n  readonly scheduledTime: number;\n  readonly cron: string;\n  noRetry(): void;\n}\nexport interface QueuingStrategy<T = any> {\n  highWaterMark?: number | bigint;\n  size?: (chunk: T) => number | bigint;\n}\nexport interface UnderlyingSink<W = any> {\n  type?: string;\n  start?: (controller: WritableStreamDefaultController) => void | Promise<void>;\n  write?: (\n    chunk: W,\n    controller: WritableStreamDefaultController\n  ) => void | Promise<void>;\n  abort?: (reason: any) => void | Promise<void>;\n  close?: () => void | Promise<void>;\n}\nexport interface UnderlyingByteSource {\n  type: \"bytes\";\n  autoAllocateChunkSize?: number;\n  start?: (controller: ReadableByteStreamController) => void | Promise<void>;\n  pull?: (controller: ReadableByteStreamController) => void | Promise<void>;\n  cancel?: (reason: any) => void | Promise<void>;\n}\nexport interface UnderlyingSource<R = any> {\n  type?: \"\" | undefined;\n  start?: (\n    controller: ReadableStreamDefaultController<R>\n  ) => void | Promise<void>;\n  pull?: (\n    controller: ReadableStreamDefaultController<R>\n  ) => void | Promise<void>;\n  cancel?: (reason: any) => void | Promise<void>;\n  expectedLength?: number | bigint;\n}\nexport interface Transformer<I = any, O = any> {\n  readableType?: string;\n  writableType?: string;\n  start?: (\n    controller: TransformStreamDefaultController<O>\n  ) => void | Promise<void>;\n  transform?: (\n    chunk: I,\n    controller: TransformStreamDefaultController<O>\n  ) => void | Promise<void>;\n  flush?: (\n    controller: TransformStreamDefaultController<O>\n  ) => void | Promise<void>;\n  expectedLength?: number | bigint;\n}\nexport interface StreamPipeOptions {\n  /**\n   * Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   *\n   * Errors and closures of the source and destination streams propagate as follows:\n   *\n   * An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source's error, or with any error that occurs during aborting the destination.\n   *\n   * An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination's error, or with any error that occurs during canceling the source.\n   *\n   * When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.\n   *\n   * If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.\n   *\n   * The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.\n   */\n  preventClose?: boolean;\n  preventAbort?: boolean;\n  preventCancel?: boolean;\n  signal?: AbortSignal;\n}\nexport type ReadableStreamReadResult<R = any> =\n  | {\n      done: false;\n      value: R;\n    }\n  | {\n      done: true;\n      value?: undefined;\n    };\n/** This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object. */\nexport interface ReadableStream<R = any> {\n  get locked(): boolean;\n  cancel(reason?: any): Promise<void>;\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(options: ReadableStreamGetReaderOptions): ReadableStreamBYOBReader;\n  pipeThrough<T>(\n    transform: ReadableWritablePair<T, R>,\n    options?: StreamPipeOptions\n  ): ReadableStream<T>;\n  pipeTo(\n    destination: WritableStream<R>,\n    options?: StreamPipeOptions\n  ): Promise<void>;\n  tee(): [ReadableStream<R>, ReadableStream<R>];\n  values(options?: ReadableStreamValuesOptions): AsyncIterableIterator<R>;\n  [Symbol.asyncIterator](\n    options?: ReadableStreamValuesOptions\n  ): AsyncIterableIterator<R>;\n}\nexport declare const ReadableStream: {\n  prototype: ReadableStream;\n  new (\n    underlyingSource: UnderlyingByteSource,\n    strategy?: QueuingStrategy<Uint8Array>\n  ): ReadableStream<Uint8Array>;\n  new <R = any>(\n    underlyingSource?: UnderlyingSource<R>,\n    strategy?: QueuingStrategy<R>\n  ): ReadableStream<R>;\n};\nexport declare class ReadableStreamDefaultReader<R = any> {\n  constructor(stream: ReadableStream);\n  get closed(): Promise<void>;\n  cancel(reason?: any): Promise<void>;\n  read(): Promise<ReadableStreamReadResult<R>>;\n  releaseLock(): void;\n}\nexport declare class ReadableStreamBYOBReader {\n  constructor(stream: ReadableStream);\n  get closed(): Promise<void>;\n  cancel(reason?: any): Promise<void>;\n  read<T extends ArrayBufferView>(\n    view: T\n  ): Promise<ReadableStreamReadResult<T>>;\n  releaseLock(): void;\n  readAtLeast<T extends ArrayBufferView>(\n    minElements: number,\n    view: T\n  ): Promise<ReadableStreamReadResult<T>>;\n}\nexport interface ReadableStreamGetReaderOptions {\n  mode: \"byob\";\n}\nexport declare abstract class ReadableStreamBYOBRequest {\n  readonly view: Uint8Array | null;\n  respond(bytesWritten: number): void;\n  respondWithNewView(view: ArrayBuffer | ArrayBufferView): void;\n  readonly atLeast: number | null;\n}\nexport declare abstract class ReadableStreamDefaultController<R = any> {\n  readonly desiredSize: number | null;\n  close(): void;\n  enqueue(chunk?: R): void;\n  error(reason: any): void;\n}\nexport declare abstract class ReadableByteStreamController {\n  readonly byobRequest: ReadableStreamBYOBRequest | null;\n  readonly desiredSize: number | null;\n  close(): void;\n  enqueue(chunk: ArrayBuffer | ArrayBufferView): void;\n  error(reason: any): void;\n}\nexport declare abstract class WritableStreamDefaultController {\n  readonly signal: AbortSignal;\n  error(reason?: any): void;\n}\nexport interface TransformStreamDefaultController<O = any> {\n  get desiredSize(): number | null;\n  enqueue(chunk?: O): void;\n  error(reason: any): void;\n  terminate(): void;\n}\nexport interface ReadableWritablePair<R = any, W = any> {\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other { writable, readable } pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  writable: WritableStream<W>;\n  readable: ReadableStream<R>;\n}\nexport declare class WritableStream<W = any> {\n  constructor(\n    underlyingSink?: UnderlyingSink,\n    queuingStrategy?: QueuingStrategy\n  );\n  get locked(): boolean;\n  abort(reason?: any): Promise<void>;\n  close(): Promise<void>;\n  getWriter(): WritableStreamDefaultWriter<W>;\n}\nexport declare class WritableStreamDefaultWriter<W = any> {\n  constructor(stream: WritableStream);\n  get closed(): Promise<void>;\n  get ready(): Promise<void>;\n  get desiredSize(): number | null;\n  abort(reason?: any): Promise<void>;\n  close(): Promise<void>;\n  write(chunk?: W): Promise<void>;\n  releaseLock(): void;\n}\nexport declare class TransformStream<I = any, O = any> {\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  get readable(): ReadableStream<O>;\n  get writable(): WritableStream<I>;\n}\nexport declare class FixedLengthStream extends IdentityTransformStream {\n  constructor(\n    expectedLength: number | bigint,\n    queuingStrategy?: IdentityTransformStreamQueuingStrategy\n  );\n}\nexport declare class IdentityTransformStream extends TransformStream<\n  ArrayBuffer | ArrayBufferView,\n  Uint8Array\n> {\n  constructor(queuingStrategy?: IdentityTransformStreamQueuingStrategy);\n}\nexport interface IdentityTransformStreamQueuingStrategy {\n  highWaterMark?: number | bigint;\n}\nexport interface ReadableStreamValuesOptions {\n  preventCancel?: boolean;\n}\nexport declare class CompressionStream extends TransformStream<\n  ArrayBuffer | ArrayBufferView,\n  Uint8Array\n> {\n  constructor(format: \"gzip\" | \"deflate\" | \"deflate-raw\");\n}\nexport declare class DecompressionStream extends TransformStream<\n  ArrayBuffer | ArrayBufferView,\n  Uint8Array\n> {\n  constructor(format: \"gzip\" | \"deflate\" | \"deflate-raw\");\n}\nexport declare class TextEncoderStream extends TransformStream<\n  string,\n  Uint8Array\n> {\n  constructor();\n}\nexport declare class TextDecoderStream extends TransformStream<\n  ArrayBuffer | ArrayBufferView,\n  string\n> {\n  constructor(label?: string, options?: TextDecoderStreamTextDecoderStreamInit);\n}\nexport interface TextDecoderStreamTextDecoderStreamInit {\n  fatal?: boolean;\n}\nexport declare class ByteLengthQueuingStrategy\n  implements QueuingStrategy<ArrayBufferView>\n{\n  constructor(init: QueuingStrategyInit);\n  get highWaterMark(): number;\n  get size(): (chunk?: any) => number;\n}\nexport declare class CountQueuingStrategy implements QueuingStrategy {\n  constructor(init: QueuingStrategyInit);\n  get highWaterMark(): number;\n  get size(): (chunk?: any) => number;\n}\nexport interface QueuingStrategyInit {\n  /**\n   * Creates a new ByteLengthQueuingStrategy with the provided high water mark.\n   *\n   * Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting ByteLengthQueuingStrategy will cause the corresponding stream constructor to throw.\n   */\n  highWaterMark: number;\n}\nexport interface ScriptVersion {\n  id?: string;\n  tag?: string;\n  message?: string;\n}\nexport declare abstract class TailEvent extends ExtendableEvent {\n  readonly events: TraceItem[];\n  readonly traces: TraceItem[];\n}\nexport interface TraceItem {\n  readonly event:\n    | (\n        | TraceItemFetchEventInfo\n        | TraceItemScheduledEventInfo\n        | TraceItemAlarmEventInfo\n        | TraceItemQueueEventInfo\n        | TraceItemEmailEventInfo\n        | TraceItemTailEventInfo\n        | TraceItemCustomEventInfo\n        | TraceItemHibernatableWebSocketEventInfo\n      )\n    | null;\n  readonly eventTimestamp: number | null;\n  readonly logs: TraceLog[];\n  readonly exceptions: TraceException[];\n  readonly diagnosticsChannelEvents: TraceDiagnosticChannelEvent[];\n  readonly scriptName: string | null;\n  readonly scriptVersion?: ScriptVersion;\n  readonly dispatchNamespace?: string;\n  readonly scriptTags?: string[];\n  readonly outcome: string;\n}\nexport interface TraceItemAlarmEventInfo {\n  readonly scheduledTime: Date;\n}\nexport interface TraceItemCustomEventInfo {}\nexport interface TraceItemScheduledEventInfo {\n  readonly scheduledTime: number;\n  readonly cron: string;\n}\nexport interface TraceItemQueueEventInfo {\n  readonly queue: string;\n  readonly batchSize: number;\n}\nexport interface TraceItemEmailEventInfo {\n  readonly mailFrom: string;\n  readonly rcptTo: string;\n  readonly rawSize: number;\n}\nexport interface TraceItemTailEventInfo {\n  readonly consumedEvents: TraceItemTailEventInfoTailItem[];\n}\nexport interface TraceItemTailEventInfoTailItem {\n  readonly scriptName: string | null;\n}\nexport interface TraceItemFetchEventInfo {\n  readonly response?: TraceItemFetchEventInfoResponse;\n  readonly request: TraceItemFetchEventInfoRequest;\n}\nexport interface TraceItemFetchEventInfoRequest {\n  readonly cf?: any;\n  readonly headers: Record<string, string>;\n  readonly method: string;\n  readonly url: string;\n  getUnredacted(): TraceItemFetchEventInfoRequest;\n}\nexport interface TraceItemFetchEventInfoResponse {\n  readonly status: number;\n}\nexport interface TraceItemHibernatableWebSocketEventInfo {\n  readonly getWebSocketEvent:\n    | TraceItemHibernatableWebSocketEventInfoMessage\n    | TraceItemHibernatableWebSocketEventInfoClose\n    | TraceItemHibernatableWebSocketEventInfoError;\n}\nexport interface TraceItemHibernatableWebSocketEventInfoMessage {\n  readonly webSocketEventType: string;\n}\nexport interface TraceItemHibernatableWebSocketEventInfoClose {\n  readonly webSocketEventType: string;\n  readonly code: number;\n  readonly wasClean: boolean;\n}\nexport interface TraceItemHibernatableWebSocketEventInfoError {\n  readonly webSocketEventType: string;\n}\nexport interface TraceLog {\n  readonly timestamp: number;\n  readonly level: string;\n  readonly message: any;\n}\nexport interface TraceException {\n  readonly timestamp: number;\n  readonly message: string;\n  readonly name: string;\n}\nexport interface TraceDiagnosticChannelEvent {\n  readonly timestamp: number;\n  readonly channel: string;\n  readonly message: any;\n}\nexport interface TraceMetrics {\n  readonly cpuTime: number;\n  readonly wallTime: number;\n}\nexport interface UnsafeTraceMetrics {\n  fromTrace(item: TraceItem): TraceMetrics;\n}\nexport declare class URL {\n  constructor(url: string | URL, base?: string | URL);\n  get origin(): string;\n  get href(): string;\n  set href(value: string);\n  get protocol(): string;\n  set protocol(value: string);\n  get username(): string;\n  set username(value: string);\n  get password(): string;\n  set password(value: string);\n  get host(): string;\n  set host(value: string);\n  get hostname(): string;\n  set hostname(value: string);\n  get port(): string;\n  set port(value: string);\n  get pathname(): string;\n  set pathname(value: string);\n  get search(): string;\n  set search(value: string);\n  get hash(): string;\n  set hash(value: string);\n  get searchParams(): URLSearchParams;\n  toJSON(): string;\n  toString(): string;\n  static canParse(url: string, base?: string): boolean;\n}\nexport declare class URLSearchParams {\n  constructor(\n    init?: Iterable<Iterable<string>> | Record<string, string> | string\n  );\n  get size(): number;\n  append(name: string, value: string): void;\n  delete(name: string, value?: string): void;\n  get(name: string): string | null;\n  getAll(name: string): string[];\n  has(name: string, value?: string): boolean;\n  set(name: string, value: string): void;\n  sort(): void;\n  entries(): IterableIterator<[key: string, value: string]>;\n  keys(): IterableIterator<string>;\n  values(): IterableIterator<string>;\n  forEach<This = unknown>(\n    callback: (\n      this: This,\n      value: string,\n      key: string,\n      parent: URLSearchParams\n    ) => void,\n    thisArg?: This\n  ): void;\n  toString(): string;\n  [Symbol.iterator](): IterableIterator<[key: string, value: string]>;\n}\nexport declare class URLPattern {\n  constructor(input?: string | URLPatternURLPatternInit, baseURL?: string);\n  get protocol(): string;\n  get username(): string;\n  get password(): string;\n  get hostname(): string;\n  get port(): string;\n  get pathname(): string;\n  get search(): string;\n  get hash(): string;\n  test(input?: string | URLPatternURLPatternInit, baseURL?: string): boolean;\n  exec(\n    input?: string | URLPatternURLPatternInit,\n    baseURL?: string\n  ): URLPatternURLPatternResult | null;\n}\nexport interface URLPatternURLPatternInit {\n  protocol?: string;\n  username?: string;\n  password?: string;\n  hostname?: string;\n  port?: string;\n  pathname?: string;\n  search?: string;\n  hash?: string;\n  baseURL?: string;\n}\nexport interface URLPatternURLPatternComponentResult {\n  input: string;\n  groups: Record<string, string>;\n}\nexport interface URLPatternURLPatternResult {\n  inputs: (string | URLPatternURLPatternInit)[];\n  protocol: URLPatternURLPatternComponentResult;\n  username: URLPatternURLPatternComponentResult;\n  password: URLPatternURLPatternComponentResult;\n  hostname: URLPatternURLPatternComponentResult;\n  port: URLPatternURLPatternComponentResult;\n  pathname: URLPatternURLPatternComponentResult;\n  search: URLPatternURLPatternComponentResult;\n  hash: URLPatternURLPatternComponentResult;\n}\nexport declare class CloseEvent extends Event {\n  constructor(type: string, initializer: CloseEventInit);\n  /** Returns the WebSocket connection close code provided by the server. */\n  readonly code: number;\n  /** Returns the WebSocket connection close reason provided by the server. */\n  readonly reason: string;\n  /** Returns true if the connection closed cleanly; false otherwise. */\n  readonly wasClean: boolean;\n}\nexport interface CloseEventInit {\n  code?: number;\n  reason?: string;\n  wasClean?: boolean;\n}\nexport declare class MessageEvent extends Event {\n  constructor(type: string, initializer: MessageEventInit);\n  readonly data: ArrayBuffer | string;\n}\nexport interface MessageEventInit {\n  data: ArrayBuffer | string;\n}\n/** Events providing information related to errors in scripts or in files. */\nexport interface ErrorEvent extends Event {\n  readonly filename: string;\n  readonly message: string;\n  readonly lineno: number;\n  readonly colno: number;\n  readonly error: any;\n}\nexport type WebSocketEventMap = {\n  close: CloseEvent;\n  message: MessageEvent;\n  open: Event;\n  error: ErrorEvent;\n};\nexport declare class WebSocket extends EventTarget<WebSocketEventMap> {\n  constructor(url: string, protocols?: string[] | string);\n  accept(): void;\n  send(message: (ArrayBuffer | ArrayBufferView) | string): void;\n  close(code?: number, reason?: string): void;\n  serializeAttachment(attachment: any): void;\n  deserializeAttachment(): any | null;\n  static readonly READY_STATE_CONNECTING: number;\n  static readonly CONNECTING: number;\n  static readonly READY_STATE_OPEN: number;\n  static readonly OPEN: number;\n  static readonly READY_STATE_CLOSING: number;\n  static readonly CLOSING: number;\n  static readonly READY_STATE_CLOSED: number;\n  static readonly CLOSED: number;\n  get readyState(): number;\n  get url(): string | null;\n  get protocol(): string | null;\n  get extensions(): string | null;\n}\nexport declare const WebSocketPair: {\n  new (): {\n    0: WebSocket;\n    1: WebSocket;\n  };\n};\nexport interface SqlStorage {\n  exec(query: string, ...bindings: any[]): SqlStorageCursor;\n  prepare(query: string): SqlStorageStatement;\n  get databaseSize(): number;\n  Cursor: typeof SqlStorageCursor;\n  Statement: typeof SqlStorageStatement;\n}\nexport declare abstract class SqlStorageStatement {}\nexport declare abstract class SqlStorageCursor {\n  raw(): IterableIterator<((ArrayBuffer | string | number) | null)[]>;\n  get columnNames(): string[];\n  get rowsRead(): number;\n  get rowsWritten(): number;\n  [Symbol.iterator](): IterableIterator<\n    Record<string, (ArrayBuffer | string | number) | null>\n  >;\n}\nexport interface Socket {\n  get readable(): ReadableStream;\n  get writable(): WritableStream;\n  get closed(): Promise<void>;\n  get opened(): Promise<SocketInfo>;\n  close(): Promise<void>;\n  startTls(options?: TlsOptions): Socket;\n}\nexport interface SocketOptions {\n  secureTransport?: string;\n  allowHalfOpen: boolean;\n}\nexport interface SocketAddress {\n  hostname: string;\n  port: number;\n}\nexport interface TlsOptions {\n  expectedServerHostname?: string;\n}\nexport interface SocketInfo {\n  remoteAddress?: string;\n  localAddress?: string;\n}\nexport interface gpuGPU {\n  requestAdapter(\n    param1?: gpuGPURequestAdapterOptions\n  ): Promise<gpuGPUAdapter | null>;\n}\nexport declare abstract class gpuGPUAdapter {\n  requestDevice(param1?: gpuGPUDeviceDescriptor): Promise<gpuGPUDevice>;\n  requestAdapterInfo(unmaskHints?: string[]): Promise<gpuGPUAdapterInfo>;\n  get features(): gpuGPUSupportedFeatures;\n  get limits(): gpuGPUSupportedLimits;\n}\nexport interface gpuGPUDevice extends EventTarget {\n  createBuffer(param1: gpuGPUBufferDescriptor): gpuGPUBuffer;\n  createBindGroupLayout(\n    descriptor: gpuGPUBindGroupLayoutDescriptor\n  ): gpuGPUBindGroupLayout;\n  createBindGroup(descriptor: gpuGPUBindGroupDescriptor): gpuGPUBindGroup;\n  createSampler(descriptor: gpuGPUSamplerDescriptor): gpuGPUSampler;\n  createShaderModule(\n    descriptor: gpuGPUShaderModuleDescriptor\n  ): gpuGPUShaderModule;\n  createPipelineLayout(\n    descriptor: gpuGPUPipelineLayoutDescriptor\n  ): gpuGPUPipelineLayout;\n  createComputePipeline(\n    descriptor: gpuGPUComputePipelineDescriptor\n  ): gpuGPUComputePipeline;\n  createRenderPipeline(\n    descriptor: gpuGPURenderPipelineDescriptor\n  ): gpuGPURenderPipeline;\n  createCommandEncoder(\n    descriptor?: gpuGPUCommandEncoderDescriptor\n  ): gpuGPUCommandEncoder;\n  createTexture(param1: gpuGPUTextureDescriptor): gpuGPUTexture;\n  destroy(): void;\n  createQuerySet(descriptor: gpuGPUQuerySetDescriptor): gpuGPUQuerySet;\n  pushErrorScope(filter: string): void;\n  popErrorScope(): Promise<gpuGPUError | null>;\n  get queue(): gpuGPUQueue;\n  get lost(): Promise<gpuGPUDeviceLostInfo>;\n  get features(): gpuGPUSupportedFeatures;\n  get limits(): gpuGPUSupportedLimits;\n}\nexport interface gpuGPUDeviceDescriptor {\n  label?: string;\n  requiredFeatures?: string[];\n  requiredLimits?: Record<string, number | bigint>;\n  defaultQueue?: gpuGPUQueueDescriptor;\n}\nexport interface gpuGPUBufferDescriptor {\n  label: string;\n  size: number | bigint;\n  usage: number;\n  mappedAtCreation: boolean;\n}\nexport interface gpuGPUQueueDescriptor {\n  label?: string;\n}\nexport declare abstract class gpuGPUBufferUsage {\n  static readonly MAP_READ: number;\n  static readonly MAP_WRITE: number;\n  static readonly COPY_SRC: number;\n  static readonly COPY_DST: number;\n  static readonly INDEX: number;\n  static readonly VERTEX: number;\n  static readonly UNIFORM: number;\n  static readonly STORAGE: number;\n  static readonly INDIRECT: number;\n  static readonly QUERY_RESOLVE: number;\n}\nexport interface gpuGPUBuffer {\n  getMappedRange(size?: number | bigint, param2?: number | bigint): ArrayBuffer;\n  unmap(): void;\n  destroy(): void;\n  mapAsync(\n    mode: number,\n    offset?: number | bigint,\n    size?: number | bigint\n  ): Promise<void>;\n  get size(): number | bigint;\n  get usage(): number;\n  get mapState(): string;\n}\nexport declare abstract class gpuGPUShaderStage {\n  static readonly VERTEX: number;\n  static readonly FRAGMENT: number;\n  static readonly COMPUTE: number;\n}\nexport interface gpuGPUBindGroupLayoutDescriptor {\n  label?: string;\n  entries: gpuGPUBindGroupLayoutEntry[];\n}\nexport interface gpuGPUBindGroupLayoutEntry {\n  binding: number;\n  visibility: number;\n  buffer?: gpuGPUBufferBindingLayout;\n  sampler?: gpuGPUSamplerBindingLayout;\n  texture?: gpuGPUTextureBindingLayout;\n  storageTexture?: gpuGPUStorageTextureBindingLayout;\n}\nexport interface gpuGPUStorageTextureBindingLayout {\n  access?: string;\n  format: string;\n  viewDimension?: string;\n}\nexport interface gpuGPUTextureBindingLayout {\n  sampleType?: string;\n  viewDimension?: string;\n  multisampled?: boolean;\n}\nexport interface gpuGPUSamplerBindingLayout {\n  type?: string;\n}\nexport interface gpuGPUBufferBindingLayout {\n  type?: string;\n  hasDynamicOffset?: boolean;\n  minBindingSize?: number | bigint;\n}\nexport interface gpuGPUBindGroupLayout {}\nexport interface gpuGPUBindGroup {}\nexport interface gpuGPUBindGroupDescriptor {\n  label?: string;\n  layout: gpuGPUBindGroupLayout;\n  entries: gpuGPUBindGroupEntry[];\n}\nexport interface gpuGPUBindGroupEntry {\n  binding: number;\n  resource: gpuGPUBufferBinding | gpuGPUSampler;\n}\nexport interface gpuGPUBufferBinding {\n  buffer: gpuGPUBuffer;\n  offset?: number | bigint;\n  size?: number | bigint;\n}\nexport interface gpuGPUSampler {}\nexport interface gpuGPUSamplerDescriptor {\n  label?: string;\n  addressModeU?: string;\n  addressModeV?: string;\n  addressModeW?: string;\n  magFilter?: string;\n  minFilter?: string;\n  mipmapFilter?: string;\n  lodMinClamp?: number;\n  lodMaxClamp?: number;\n  compare: string;\n  maxAnisotropy?: number;\n}\nexport interface gpuGPUShaderModule {\n  getCompilationInfo(): Promise<gpuGPUCompilationInfo>;\n}\nexport interface gpuGPUShaderModuleDescriptor {\n  label?: string;\n  code: string;\n}\nexport interface gpuGPUPipelineLayout {}\nexport interface gpuGPUPipelineLayoutDescriptor {\n  label?: string;\n  bindGroupLayouts: gpuGPUBindGroupLayout[];\n}\nexport interface gpuGPUComputePipeline {\n  getBindGroupLayout(index: number): gpuGPUBindGroupLayout;\n}\nexport interface gpuGPUComputePipelineDescriptor {\n  label?: string;\n  compute: gpuGPUProgrammableStage;\n  layout: string | gpuGPUPipelineLayout;\n}\nexport interface gpuGPUProgrammableStage {\n  module: gpuGPUShaderModule;\n  entryPoint: string;\n  constants?: Record<string, number>;\n}\nexport interface gpuGPUCommandEncoder {\n  get label(): string;\n  beginComputePass(\n    descriptor?: gpuGPUComputePassDescriptor\n  ): gpuGPUComputePassEncoder;\n  beginRenderPass(\n    descriptor: gpuGPURenderPassDescriptor\n  ): gpuGPURenderPassEncoder;\n  copyBufferToBuffer(\n    source: gpuGPUBuffer,\n    sourceOffset: number | bigint,\n    destination: gpuGPUBuffer,\n    destinationOffset: number | bigint,\n    size: number | bigint\n  ): void;\n  finish(param0?: gpuGPUCommandBufferDescriptor): gpuGPUCommandBuffer;\n  copyTextureToBuffer(\n    source: gpuGPUImageCopyTexture,\n    destination: gpuGPUImageCopyBuffer,\n    copySize: Iterable<number> | gpuGPUExtent3DDict\n  ): void;\n  copyBufferToTexture(\n    source: gpuGPUImageCopyBuffer,\n    destination: gpuGPUImageCopyTexture,\n    copySize: Iterable<number> | gpuGPUExtent3DDict\n  ): void;\n  copyTextureToTexture(\n    source: gpuGPUImageCopyTexture,\n    destination: gpuGPUImageCopyTexture,\n    copySize: Iterable<number> | gpuGPUExtent3DDict\n  ): void;\n  clearBuffer(\n    buffer: gpuGPUBuffer,\n    offset?: number | bigint,\n    size?: number | bigint\n  ): void;\n}\nexport interface gpuGPUCommandEncoderDescriptor {\n  label?: string;\n}\nexport interface gpuGPUComputePassEncoder {\n  setPipeline(pipeline: gpuGPUComputePipeline): void;\n  setBindGroup(\n    index: number,\n    bindGroup: gpuGPUBindGroup | null,\n    dynamicOffsets?: Iterable<number>\n  ): void;\n  dispatchWorkgroups(\n    workgroupCountX: number,\n    workgroupCountY?: number,\n    workgroupCountZ?: number\n  ): void;\n  end(): void;\n}\nexport interface gpuGPUComputePassDescriptor {\n  label?: string;\n  timestampWrites?: gpuGPUComputePassTimestampWrites;\n}\nexport interface gpuGPUQuerySet {}\nexport interface gpuGPUQuerySetDescriptor {\n  label?: string;\n}\nexport interface gpuGPUComputePassTimestampWrites {\n  querySet: gpuGPUQuerySet;\n  beginningOfPassWriteIndex?: number;\n  endOfPassWriteIndex?: number;\n}\nexport interface gpuGPUCommandBufferDescriptor {\n  label?: string;\n}\nexport interface gpuGPUCommandBuffer {}\nexport interface gpuGPUQueue {\n  submit(commandBuffers: gpuGPUCommandBuffer[]): void;\n  writeBuffer(\n    buffer: gpuGPUBuffer,\n    bufferOffset: number | bigint,\n    data: ArrayBuffer | ArrayBufferView,\n    dataOffset?: number | bigint,\n    size?: number | bigint\n  ): void;\n}\nexport declare abstract class gpuGPUMapMode {\n  static readonly READ: number;\n  static readonly WRITE: number;\n}\nexport interface gpuGPURequestAdapterOptions {\n  powerPreference: string;\n  forceFallbackAdapter?: boolean;\n}\nexport interface gpuGPUAdapterInfo {\n  get vendor(): string;\n  get architecture(): string;\n  get device(): string;\n  get description(): string;\n}\nexport interface gpuGPUSupportedFeatures {\n  has(name: string): boolean;\n  keys(): string[];\n}\nexport interface gpuGPUSupportedLimits {\n  get maxTextureDimension1D(): number;\n  get maxTextureDimension2D(): number;\n  get maxTextureDimension3D(): number;\n  get maxTextureArrayLayers(): number;\n  get maxBindGroups(): number;\n  get maxBindingsPerBindGroup(): number;\n  get maxDynamicUniformBuffersPerPipelineLayout(): number;\n  get maxDynamicStorageBuffersPerPipelineLayout(): number;\n  get maxSampledTexturesPerShaderStage(): number;\n  get maxSamplersPerShaderStage(): number;\n  get maxStorageBuffersPerShaderStage(): number;\n  get maxStorageTexturesPerShaderStage(): number;\n  get maxUniformBuffersPerShaderStage(): number;\n  get maxUniformBufferBindingSize(): number | bigint;\n  get maxStorageBufferBindingSize(): number | bigint;\n  get minUniformBufferOffsetAlignment(): number;\n  get minStorageBufferOffsetAlignment(): number;\n  get maxVertexBuffers(): number;\n  get maxBufferSize(): number | bigint;\n  get maxVertexAttributes(): number;\n  get maxVertexBufferArrayStride(): number;\n  get maxInterStageShaderComponents(): number;\n  get maxInterStageShaderVariables(): number;\n  get maxColorAttachments(): number;\n  get maxColorAttachmentBytesPerSample(): number;\n  get maxComputeWorkgroupStorageSize(): number;\n  get maxComputeInvocationsPerWorkgroup(): number;\n  get maxComputeWorkgroupSizeX(): number;\n  get maxComputeWorkgroupSizeY(): number;\n  get maxComputeWorkgroupSizeZ(): number;\n  get maxComputeWorkgroupsPerDimension(): number;\n}\nexport declare abstract class gpuGPUError {\n  get message(): string;\n}\nexport declare abstract class gpuGPUOutOfMemoryError extends gpuGPUError {}\nexport declare abstract class gpuGPUInternalError extends gpuGPUError {}\nexport declare abstract class gpuGPUValidationError extends gpuGPUError {}\nexport declare abstract class gpuGPUDeviceLostInfo {\n  get message(): string;\n  get reason(): string;\n}\nexport interface gpuGPUCompilationMessage {\n  get message(): string;\n  get type(): string;\n  get lineNum(): number;\n  get linePos(): number;\n  get offset(): number;\n  get length(): number;\n}\nexport interface gpuGPUCompilationInfo {\n  get messages(): gpuGPUCompilationMessage[];\n}\nexport declare abstract class gpuGPUTextureUsage {\n  static readonly COPY_SRC: number;\n  static readonly COPY_DST: number;\n  static readonly TEXTURE_BINDING: number;\n  static readonly STORAGE_BINDING: number;\n  static readonly RENDER_ATTACHMENT: number;\n}\nexport interface gpuGPUTextureDescriptor {\n  label: string;\n  size: number[] | gpuGPUExtent3DDict;\n  mipLevelCount?: number;\n  sampleCount?: number;\n  dimension?: string;\n  format: string;\n  usage: number;\n  viewFormats?: string[];\n}\nexport interface gpuGPUExtent3DDict {\n  width: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n}\nexport interface gpuGPUTexture {\n  createView(descriptor?: gpuGPUTextureViewDescriptor): gpuGPUTextureView;\n  destroy(): void;\n  get width(): number;\n  get height(): number;\n  get depthOrArrayLayers(): number;\n  get mipLevelCount(): number;\n  get dimension(): string;\n  get format(): string;\n  get usage(): number;\n}\nexport interface gpuGPUTextureView {}\nexport interface gpuGPUTextureViewDescriptor {\n  label: string;\n  format: string;\n  dimension: string;\n  aspect?: string;\n  baseMipLevel?: number;\n  mipLevelCount: number;\n  baseArrayLayer?: number;\n  arrayLayerCount: number;\n}\nexport declare abstract class gpuGPUColorWrite {\n  static readonly RED: number;\n  static readonly GREEN: number;\n  static readonly BLUE: number;\n  static readonly ALPHA: number;\n  static readonly ALL: number;\n}\nexport interface gpuGPURenderPipeline {}\nexport interface gpuGPURenderPipelineDescriptor {\n  label?: string;\n  layout: string | gpuGPUPipelineLayout;\n  vertex: gpuGPUVertexState;\n  primitive?: gpuGPUPrimitiveState;\n  depthStencil?: gpuGPUDepthStencilState;\n  multisample?: gpuGPUMultisampleState;\n  fragment?: gpuGPUFragmentState;\n}\nexport interface gpuGPUVertexState {\n  module: gpuGPUShaderModule;\n  entryPoint: string;\n  constants?: Record<string, number>;\n  buffers?: gpuGPUVertexBufferLayout[];\n}\nexport interface gpuGPUVertexBufferLayout {\n  arrayStride: number | bigint;\n  stepMode?: string;\n  attributes: gpuGPUVertexAttribute[];\n}\nexport interface gpuGPUVertexAttribute {\n  format: string;\n  offset: number | bigint;\n  shaderLocation: number;\n}\nexport interface gpuGPUPrimitiveState {\n  topology?: string;\n  stripIndexFormat?: string;\n  frontFace?: string;\n  cullMode?: string;\n  unclippedDepth?: boolean;\n}\nexport interface gpuGPUStencilFaceState {\n  compare?: string;\n  failOp?: string;\n  depthFailOp?: string;\n  passOp?: string;\n}\nexport interface gpuGPUDepthStencilState {\n  format: string;\n  depthWriteEnabled: boolean;\n  depthCompare: string;\n  stencilFront?: gpuGPUStencilFaceState;\n  stencilBack?: gpuGPUStencilFaceState;\n  stencilReadMask?: number;\n  stencilWriteMask?: number;\n  depthBias?: number;\n  depthBiasSlopeScale?: number;\n  depthBiasClamp?: number;\n}\nexport interface gpuGPUMultisampleState {\n  count?: number;\n  mask?: number;\n  alphaToCoverageEnabled?: boolean;\n}\nexport interface gpuGPUFragmentState {\n  module: gpuGPUShaderModule;\n  entryPoint: string;\n  constants?: Record<string, number>;\n  targets: gpuGPUColorTargetState[];\n}\nexport interface gpuGPUColorTargetState {\n  format: string;\n  blend: gpuGPUBlendState;\n  writeMask?: number;\n}\nexport interface gpuGPUBlendState {\n  color: gpuGPUBlendComponent;\n  alpha: gpuGPUBlendComponent;\n}\nexport interface gpuGPUBlendComponent {\n  operation?: string;\n  srcFactor?: string;\n  dstFactor?: string;\n}\nexport interface gpuGPURenderPassEncoder {\n  setPipeline(pipeline: gpuGPURenderPipeline): void;\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number\n  ): void;\n  end(): void;\n}\nexport interface gpuGPURenderPassDescriptor {\n  label?: string;\n  colorAttachments: gpuGPURenderPassColorAttachment[];\n  depthStencilAttachment?: gpuGPURenderPassDepthStencilAttachment;\n  occlusionQuerySet?: gpuGPUQuerySet;\n  timestampWrites?: gpuGPURenderPassTimestampWrites;\n  maxDrawCount?: number | bigint;\n}\nexport interface gpuGPURenderPassColorAttachment {\n  view: gpuGPUTextureView;\n  depthSlice?: number;\n  resolveTarget?: gpuGPUTextureView;\n  clearValue?: number[] | gpuGPUColorDict;\n  loadOp: string;\n  storeOp: string;\n}\nexport interface gpuGPUColorDict {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\nexport interface gpuGPURenderPassDepthStencilAttachment {\n  view: gpuGPUTextureView;\n  depthClearValue?: number;\n  depthLoadOp?: string;\n  depthStoreOp?: string;\n  depthReadOnly?: boolean;\n  stencilClearValue?: number;\n  stencilLoadOp?: string;\n  stencilStoreOp?: string;\n  stencilReadOnly?: boolean;\n}\nexport interface gpuGPURenderPassTimestampWrites {\n  querySet: gpuGPUQuerySet;\n  beginningOfPassWriteIndex?: number;\n  endOfPassWriteIndex?: number;\n}\nexport interface gpuGPUImageCopyTexture {\n  texture: gpuGPUTexture;\n  mipLevel?: number;\n  origin?: number[] | gpuGPUOrigin3DDict;\n  aspect?: string;\n}\nexport interface gpuGPUImageCopyBuffer {\n  buffer: gpuGPUBuffer;\n  offset?: number | bigint;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\nexport interface gpuGPUOrigin3DDict {\n  x?: number;\n  y?: number;\n  z?: number;\n}\nexport interface BasicImageTransformations {\n  /**\n   * Maximum width in image pixels. The value must be an integer.\n   */\n  width?: number;\n  /**\n   * Maximum height in image pixels. The value must be an integer.\n   */\n  height?: number;\n  /**\n   * Resizing mode as a string. It affects interpretation of width and height\n   * options:\n   *  - scale-down: Similar to contain, but the image is never enlarged. If\n   *    the image is larger than given width or height, it will be resized.\n   *    Otherwise its original size will be kept.\n   *  - contain: Resizes to maximum size that fits within the given width and\n   *    height. If only a single dimension is given (e.g. only width), the\n   *    image will be shrunk or enlarged to exactly match that dimension.\n   *    Aspect ratio is always preserved.\n   *  - cover: Resizes (shrinks or enlarges) to fill the entire area of width\n   *    and height. If the image has an aspect ratio different from the ratio\n   *    of width and height, it will be cropped to fit.\n   *  - crop: The image will be shrunk and cropped to fit within the area\n   *    specified by width and height. The image will not be enlarged. For images\n   *    smaller than the given dimensions it's the same as scale-down. For\n   *    images larger than the given dimensions, it's the same as cover.\n   *    See also trim.\n   *  - pad: Resizes to the maximum size that fits within the given width and\n   *    height, and then fills the remaining area with a background color\n   *    (white by default). Use of this mode is not recommended, as the same\n   *    effect can be more efficiently achieved with the contain mode and the\n   *    CSS object-fit: contain property.\n   */\n  fit?: \"scale-down\" | \"contain\" | \"cover\" | \"crop\" | \"pad\";\n  /**\n   * When cropping with fit: \"cover\", this defines the side or point that should\n   * be left uncropped. The value is either a string\n   * \"left\", \"right\", \"top\", \"bottom\", \"auto\", or \"center\" (the default),\n   * or an object {x, y} containing focal point coordinates in the original\n   * image expressed as fractions ranging from 0.0 (top or left) to 1.0\n   * (bottom or right), 0.5 being the center. {fit: \"cover\", gravity: \"top\"} will\n   * crop bottom or left and right sides as necessary, but won\u2019t crop anything\n   * from the top. {fit: \"cover\", gravity: {x:0.5, y:0.2}} will crop each side to\n   * preserve as much as possible around a point at 20% of the height of the\n   * source image.\n   */\n  gravity?:\n    | \"left\"\n    | \"right\"\n    | \"top\"\n    | \"bottom\"\n    | \"center\"\n    | \"auto\"\n    | BasicImageTransformationsGravityCoordinates;\n  /**\n   * Background color to add underneath the image. Applies only to images with\n   * transparency (such as PNG). Accepts any CSS color (#RRGGBB, rgba(\u2026),\n   * hsl(\u2026), etc.)\n   */\n  background?: string;\n  /**\n   * Number of degrees (90, 180, 270) to rotate the image by. width and height\n   * options refer to axes after rotation.\n   */\n  rotate?: 0 | 90 | 180 | 270 | 360;\n}\nexport interface BasicImageTransformationsGravityCoordinates {\n  x: number;\n  y: number;\n}\n/**\n * In addition to the properties you can set in the RequestInit dict\n * that you pass as an argument to the Request constructor, you can\n * set certain properties of a `cf` object to control how Cloudflare\n * features are applied to that new Request.\n *\n * Note: Currently, these properties cannot be tested in the\n * playground.\n */\nexport interface RequestInitCfProperties extends Record<string, unknown> {\n  cacheEverything?: boolean;\n  /**\n   * A request's cache key is what determines if two requests are\n   * \"the same\" for caching purposes. If a request has the same cache key\n   * as some previous request, then we can serve the same cached response for\n   * both. (e.g. 'some-key')\n   *\n   * Only available for Enterprise customers.\n   */\n  cacheKey?: string;\n  /**\n   * This allows you to append additional Cache-Tag response headers\n   * to the origin response without modifications to the origin server.\n   * This will allow for greater control over the Purge by Cache Tag feature\n   * utilizing changes only in the Workers process.\n   *\n   * Only available for Enterprise customers.\n   */\n  cacheTags?: string[];\n  /**\n   * Force response to be cached for a given number of seconds. (e.g. 300)\n   */\n  cacheTtl?: number;\n  /**\n   * Force response to be cached for a given number of seconds based on the Origin status code.\n   * (e.g. { '200-299': 86400, '404': 1, '500-599': 0 })\n   */\n  cacheTtlByStatus?: Record<string, number>;\n  scrapeShield?: boolean;\n  apps?: boolean;\n  image?: RequestInitCfPropertiesImage;\n  minify?: RequestInitCfPropertiesImageMinify;\n  mirage?: boolean;\n  polish?: \"lossy\" | \"lossless\" | \"off\";\n  /**\n   * Redirects the request to an alternate origin server. You can use this,\n   * for example, to implement load balancing across several origins.\n   * (e.g.us-east.example.com)\n   *\n   * Note - For security reasons, the hostname set in resolveOverride must\n   * be proxied on the same Cloudflare zone of the incoming request.\n   * Otherwise, the setting is ignored. CNAME hosts are allowed, so to\n   * resolve to a host under a different domain or a DNS only domain first\n   * declare a CNAME record within your own zone\u2019s DNS mapping to the\n   * external hostname, set proxy on Cloudflare, then set resolveOverride\n   * to point to that CNAME record.\n   */\n  resolveOverride?: string;\n}\nexport interface RequestInitCfPropertiesImageDraw\n  extends BasicImageTransformations {\n  /**\n   * Absolute URL of the image file to use for the drawing. It can be any of\n   * the supported file formats. For drawing of watermarks or non-rectangular\n   * overlays we recommend using PNG or WebP images.\n   */\n  url: string;\n  /**\n   * Floating-point number between 0 (transparent) and 1 (opaque).\n   * For example, opacity: 0.5 makes overlay semitransparent.\n   */\n  opacity?: number;\n  /**\n   * - If set to true, the overlay image will be tiled to cover the entire\n   *   area. This is useful for stock-photo-like watermarks.\n   * - If set to \"x\", the overlay image will be tiled horizontally only\n   *   (form a line).\n   * - If set to \"y\", the overlay image will be tiled vertically only\n   *   (form a line).\n   */\n  repeat?: true | \"x\" | \"y\";\n  /**\n   * Position of the overlay image relative to a given edge. Each property is\n   * an offset in pixels. 0 aligns exactly to the edge. For example, left: 10\n   * positions left side of the overlay 10 pixels from the left edge of the\n   * image it's drawn over. bottom: 0 aligns bottom of the overlay with bottom\n   * of the background image.\n   *\n   * Setting both left & right, or both top & bottom is an error.\n   *\n   * If no position is specified, the image will be centered.\n   */\n  top?: number;\n  left?: number;\n  bottom?: number;\n  right?: number;\n}\nexport interface RequestInitCfPropertiesImage\n  extends BasicImageTransformations {\n  /**\n   * Device Pixel Ratio. Default 1. Multiplier for width/height that makes it\n   * easier to specify higher-DPI sizes in <img srcset>.\n   */\n  dpr?: number;\n  /**\n   * An object with four properties {left, top, right, bottom} that specify\n   * a number of pixels to cut off on each side. Allows removal of borders\n   * or cutting out a specific fragment of an image. Trimming is performed\n   * before resizing or rotation. Takes dpr into account.\n   */\n  trim?: {\n    left?: number;\n    top?: number;\n    right?: number;\n    bottom?: number;\n  };\n  /**\n   * Quality setting from 1-100 (useful values are in 60-90 range). Lower values\n   * make images look worse, but load faster. The default is 85. It applies only\n   * to JPEG and WebP images. It doesn\u2019t have any effect on PNG.\n   */\n  quality?: number;\n  /**\n   * Output format to generate. It can be:\n   *  - avif: generate images in AVIF format.\n   *  - webp: generate images in Google WebP format. Set quality to 100 to get\n   *    the WebP-lossless format.\n   *  - json: instead of generating an image, outputs information about the\n   *    image, in JSON format. The JSON object will contain image size\n   *    (before and after resizing), source image\u2019s MIME type, file size, etc.\n   * - jpeg: generate images in JPEG format.\n   * - png: generate images in PNG format.\n   */\n  format?: \"avif\" | \"webp\" | \"json\" | \"jpeg\" | \"png\";\n  /**\n   * Whether to preserve animation frames from input files. Default is true.\n   * Setting it to false reduces animations to still images. This setting is\n   * recommended when enlarging images or processing arbitrary user content,\n   * because large GIF animations can weigh tens or even hundreds of megabytes.\n   * It is also useful to set anim:false when using format:\"json\" to get the\n   * response quicker without the number of frames.\n   */\n  anim?: boolean;\n  /**\n   * What EXIF data should be preserved in the output image. Note that EXIF\n   * rotation and embedded color profiles are always applied (\"baked in\" into\n   * the image), and aren't affected by this option. Note that if the Polish\n   * feature is enabled, all metadata may have been removed already and this\n   * option may have no effect.\n   *  - keep: Preserve most of EXIF metadata, including GPS location if there's\n   *    any.\n   *  - copyright: Only keep the copyright tag, and discard everything else.\n   *    This is the default behavior for JPEG files.\n   *  - none: Discard all invisible EXIF metadata. Currently WebP and PNG\n   *    output formats always discard metadata.\n   */\n  metadata?: \"keep\" | \"copyright\" | \"none\";\n  /**\n   * Strength of sharpening filter to apply to the image. Floating-point\n   * number between 0 (no sharpening, default) and 10 (maximum). 1.0 is a\n   * recommended value for downscaled images.\n   */\n  sharpen?: number;\n  /**\n   * Radius of a blur filter (approximate gaussian). Maximum supported radius\n   * is 250.\n   */\n  blur?: number;\n  /**\n   * Overlays are drawn in the order they appear in the array (last array\n   * entry is the topmost layer).\n   */\n  draw?: RequestInitCfPropertiesImageDraw[];\n  /**\n   * Fetching image from authenticated origin. Setting this property will\n   * pass authentication headers (Authorization, Cookie, etc.) through to\n   * the origin.\n   */\n  \"origin-auth\"?: \"share-publicly\";\n  /**\n   * Adds a border around the image. The border is added after resizing. Border\n   * width takes dpr into account, and can be specified either using a single\n   * width property, or individually for each side.\n   */\n  border?:\n    | {\n        color: string;\n        width: number;\n      }\n    | {\n        color: string;\n        top: number;\n        right: number;\n        bottom: number;\n        left: number;\n      };\n  /**\n   * Increase brightness by a factor. A value of 1.0 equals no change, a value\n   * of 0.5 equals half brightness, and a value of 2.0 equals twice as bright.\n   * 0 is ignored.\n   */\n  brightness?: number;\n  /**\n   * Increase contrast by a factor. A value of 1.0 equals no change, a value of\n   * 0.5 equals low contrast, and a value of 2.0 equals high contrast. 0 is\n   * ignored.\n   */\n  contrast?: number;\n  /**\n   * Increase exposure by a factor. A value of 1.0 equals no change, a value of\n   * 0.5 darkens the image, and a value of 2.0 lightens the image. 0 is ignored.\n   */\n  gamma?: number;\n  /**\n   * Slightly reduces latency on a cache miss by selecting a\n   * quickest-to-compress file format, at a cost of increased file size and\n   * lower image quality. It will usually override the format option and choose\n   * JPEG over WebP or AVIF. We do not recommend using this option, except in\n   * unusual circumstances like resizing uncacheable dynamically-generated\n   * images.\n   */\n  compression?: \"fast\";\n}\nexport interface RequestInitCfPropertiesImageMinify {\n  javascript?: boolean;\n  css?: boolean;\n  html?: boolean;\n}\n/**\n * Request metadata provided by Cloudflare's edge.\n */\nexport type IncomingRequestCfProperties<HostMetadata = unknown> =\n  IncomingRequestCfPropertiesBase &\n    IncomingRequestCfPropertiesBotManagementEnterprise &\n    IncomingRequestCfPropertiesCloudflareForSaaSEnterprise<HostMetadata> &\n    IncomingRequestCfPropertiesGeographicInformation &\n    IncomingRequestCfPropertiesCloudflareAccessOrApiShield;\nexport interface IncomingRequestCfPropertiesBase\n  extends Record<string, unknown> {\n  /**\n   * [ASN](https://www.iana.org/assignments/as-numbers/as-numbers.xhtml) of the incoming request.\n   *\n   * @example 395747\n   */\n  asn: number;\n  /**\n   * The organization which owns the ASN of the incoming request.\n   *\n   * @example \"Google Cloud\"\n   */\n  asOrganization: string;\n  /**\n   * The original value of the `Accept-Encoding` header if Cloudflare modified it.\n   *\n   * @example \"gzip, deflate, br\"\n   */\n  clientAcceptEncoding?: string;\n  /**\n   * The number of milliseconds it took for the request to reach your worker.\n   *\n   * @example 22\n   */\n  clientTcpRtt?: number;\n  /**\n   * The three-letter [IATA](https://en.wikipedia.org/wiki/IATA_airport_code)\n   * airport code of the data center that the request hit.\n   *\n   * @example \"DFW\"\n   */\n  colo: string;\n  /**\n   * Represents the upstream's response to a\n   * [TCP `keepalive` message](https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html)\n   * from cloudflare.\n   *\n   * For workers with no upstream, this will always be `1`.\n   *\n   * @example 3\n   */\n  edgeRequestKeepAliveStatus: IncomingRequestCfPropertiesEdgeRequestKeepAliveStatus;\n  /**\n   * The HTTP Protocol the request used.\n   *\n   * @example \"HTTP/2\"\n   */\n  httpProtocol: string;\n  /**\n   * The browser-requested prioritization information in the request object.\n   *\n   * If no information was set, defaults to the empty string `\"\"`\n   *\n   * @example \"weight=192;exclusive=0;group=3;group-weight=127\"\n   * @default \"\"\n   */\n  requestPriority: string;\n  /**\n   * The TLS version of the connection to Cloudflare.\n   * In requests served over plaintext (without TLS), this property is the empty string `\"\"`.\n   *\n   * @example \"TLSv1.3\"\n   */\n  tlsVersion: string;\n  /**\n   * The cipher for the connection to Cloudflare.\n   * In requests served over plaintext (without TLS), this property is the empty string `\"\"`.\n   *\n   * @example \"AEAD-AES128-GCM-SHA256\"\n   */\n  tlsCipher: string;\n  /**\n   * Metadata containing the [`HELLO`](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.2) and [`FINISHED`](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.9) messages from this request's TLS handshake.\n   *\n   * If the incoming request was served over plaintext (without TLS) this field is undefined.\n   */\n  tlsExportedAuthenticator?: IncomingRequestCfPropertiesExportedAuthenticatorMetadata;\n}\nexport interface IncomingRequestCfPropertiesBotManagementBase {\n  /**\n   * Cloudflare\u2019s [level of certainty](https://developers.cloudflare.com/bots/concepts/bot-score/) that a request comes from a bot,\n   * represented as an integer percentage between `1` (almost certainly a bot) and `99` (almost certainly human).\n   *\n   * @example 54\n   */\n  score: number;\n  /**\n   * A boolean value that is true if the request comes from a good bot, like Google or Bing.\n   * Most customers choose to allow this traffic. For more details, see [Traffic from known bots](https://developers.cloudflare.com/firewall/known-issues-and-faq/#how-does-firewall-rules-handle-traffic-from-known-bots).\n   */\n  verifiedBot: boolean;\n  /**\n   * A boolean value that is true if the request originates from a\n   * Cloudflare-verified proxy service.\n   */\n  corporateProxy: boolean;\n  /**\n   * A boolean value that's true if the request matches [file extensions](https://developers.cloudflare.com/bots/reference/static-resources/) for many types of static resources.\n   */\n  staticResource: boolean;\n  /**\n   * List of IDs that correlate to the Bot Management heuristic detections made on a request (you can have multiple heuristic detections on the same request).\n   */\n  detectionIds: number[];\n}\nexport interface IncomingRequestCfPropertiesBotManagement {\n  /**\n   * Results of Cloudflare's Bot Management analysis\n   */\n  botManagement: IncomingRequestCfPropertiesBotManagementBase;\n  /**\n   * Duplicate of `botManagement.score`.\n   *\n   * @deprecated\n   */\n  clientTrustScore: number;\n}\nexport interface IncomingRequestCfPropertiesBotManagementEnterprise\n  extends IncomingRequestCfPropertiesBotManagement {\n  /**\n   * Results of Cloudflare's Bot Management analysis\n   */\n  botManagement: IncomingRequestCfPropertiesBotManagementBase & {\n    /**\n     * A [JA3 Fingerprint](https://developers.cloudflare.com/bots/concepts/ja3-fingerprint/) to help profile specific SSL/TLS clients\n     * across different destination IPs, Ports, and X509 certificates.\n     */\n    ja3Hash: string;\n  };\n}\nexport interface IncomingRequestCfPropertiesCloudflareForSaaSEnterprise<\n  HostMetadata\n> {\n  /**\n   * Custom metadata set per-host in [Cloudflare for SaaS](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/).\n   *\n   * This field is only present if you have Cloudflare for SaaS enabled on your account\n   * and you have followed the [required steps to enable it]((https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/custom-metadata/)).\n   */\n  hostMetadata: HostMetadata;\n}\nexport interface IncomingRequestCfPropertiesCloudflareAccessOrApiShield {\n  /**\n   * Information about the client certificate presented to Cloudflare.\n   *\n   * This is populated when the incoming request is served over TLS using\n   * either Cloudflare Access or API Shield (mTLS)\n   * and the presented SSL certificate has a valid\n   * [Certificate Serial Number](https://ldapwiki.com/wiki/Certificate%20Serial%20Number)\n   * (i.e., not `null` or `\"\"`).\n   *\n   * Otherwise, a set of placeholder values are used.\n   *\n   * The property `certPresented` will be set to `\"1\"` when\n   * the object is populated (i.e. the above conditions were met).\n   */\n  tlsClientAuth:\n    | IncomingRequestCfPropertiesTLSClientAuth\n    | IncomingRequestCfPropertiesTLSClientAuthPlaceholder;\n}\n/**\n * Metadata about the request's TLS handshake\n */\nexport interface IncomingRequestCfPropertiesExportedAuthenticatorMetadata {\n  /**\n   * The client's [`HELLO` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.2), encoded in hexadecimal\n   *\n   * @example \"44372ba35fa1270921d318f34c12f155dc87b682cf36a790cfaa3ba8737a1b5d\"\n   */\n  clientHandshake: string;\n  /**\n   * The server's [`HELLO` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.2), encoded in hexadecimal\n   *\n   * @example \"44372ba35fa1270921d318f34c12f155dc87b682cf36a790cfaa3ba8737a1b5d\"\n   */\n  serverHandshake: string;\n  /**\n   * The client's [`FINISHED` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.9), encoded in hexadecimal\n   *\n   * @example \"084ee802fe1348f688220e2a6040a05b2199a761f33cf753abb1b006792d3f8b\"\n   */\n  clientFinished: string;\n  /**\n   * The server's [`FINISHED` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.9), encoded in hexadecimal\n   *\n   * @example \"084ee802fe1348f688220e2a6040a05b2199a761f33cf753abb1b006792d3f8b\"\n   */\n  serverFinished: string;\n}\n/**\n * Geographic data about the request's origin.\n */\nexport interface IncomingRequestCfPropertiesGeographicInformation {\n  /**\n   * The [ISO 3166-1 Alpha 2](https://www.iso.org/iso-3166-country-codes.html) country code the request originated from.\n   *\n   * If your worker is [configured to accept TOR connections](https://support.cloudflare.com/hc/en-us/articles/203306930-Understanding-Cloudflare-Tor-support-and-Onion-Routing), this may also be `\"T1\"`, indicating a request that originated over TOR.\n   *\n   * If Cloudflare is unable to determine where the request originated this property is omitted.\n   *\n   * The country code `\"T1\"` is used for requests originating on TOR.\n   *\n   * @example \"GB\"\n   */\n  country?: Iso3166Alpha2Code | \"T1\";\n  /**\n   * If present, this property indicates that the request originated in the EU\n   *\n   * @example \"1\"\n   */\n  isEUCountry?: \"1\";\n  /**\n   * A two-letter code indicating the continent the request originated from.\n   *\n   * @example \"AN\"\n   */\n  continent?: ContinentCode;\n  /**\n   * The city the request originated from\n   *\n   * @example \"Austin\"\n   */\n  city?: string;\n  /**\n   * Postal code of the incoming request\n   *\n   * @example \"78701\"\n   */\n  postalCode?: string;\n  /**\n   * Latitude of the incoming request\n   *\n   * @example \"30.27130\"\n   */\n  latitude?: string;\n  /**\n   * Longitude of the incoming request\n   *\n   * @example \"-97.74260\"\n   */\n  longitude?: string;\n  /**\n   * Timezone of the incoming request\n   *\n   * @example \"America/Chicago\"\n   */\n  timezone?: string;\n  /**\n   * If known, the ISO 3166-2 name for the first level region associated with\n   * the IP address of the incoming request\n   *\n   * @example \"Texas\"\n   */\n  region?: string;\n  /**\n   * If known, the ISO 3166-2 code for the first-level region associated with\n   * the IP address of the incoming request\n   *\n   * @example \"TX\"\n   */\n  regionCode?: string;\n  /**\n   * Metro code (DMA) of the incoming request\n   *\n   * @example \"635\"\n   */\n  metroCode?: string;\n}\n/** Data about the incoming request's TLS certificate */\nexport interface IncomingRequestCfPropertiesTLSClientAuth {\n  /** Always `\"1\"`, indicating that the certificate was presented */\n  certPresented: \"1\";\n  /**\n   * Result of certificate verification.\n   *\n   * @example \"FAILED:self signed certificate\"\n   */\n  certVerified: Exclude<CertVerificationStatus, \"NONE\">;\n  /** The presented certificate's revokation status.\n   *\n   * - A value of `\"1\"` indicates the certificate has been revoked\n   * - A value of `\"0\"` indicates the certificate has not been revoked\n   */\n  certRevoked: \"1\" | \"0\";\n  /**\n   * The certificate issuer's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html)\n   *\n   * @example \"CN=cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare\"\n   */\n  certIssuerDN: string;\n  /**\n   * The certificate subject's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html)\n   *\n   * @example \"CN=*.cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare\"\n   */\n  certSubjectDN: string;\n  /**\n   * The certificate issuer's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html) ([RFC 2253](https://www.rfc-editor.org/rfc/rfc2253.html) formatted)\n   *\n   * @example \"CN=cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare\"\n   */\n  certIssuerDNRFC2253: string;\n  /**\n   * The certificate subject's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html) ([RFC 2253](https://www.rfc-editor.org/rfc/rfc2253.html) formatted)\n   *\n   * @example \"CN=*.cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare\"\n   */\n  certSubjectDNRFC2253: string;\n  /** The certificate issuer's distinguished name (legacy policies) */\n  certIssuerDNLegacy: string;\n  /** The certificate subject's distinguished name (legacy policies) */\n  certSubjectDNLegacy: string;\n  /**\n   * The certificate's serial number\n   *\n   * @example \"00936EACBE07F201DF\"\n   */\n  certSerial: string;\n  /**\n   * The certificate issuer's serial number\n   *\n   * @example \"2489002934BDFEA34\"\n   */\n  certIssuerSerial: string;\n  /**\n   * The certificate's Subject Key Identifier\n   *\n   * @example \"BB:AF:7E:02:3D:FA:A6:F1:3C:84:8E:AD:EE:38:98:EC:D9:32:32:D4\"\n   */\n  certSKI: string;\n  /**\n   * The certificate issuer's Subject Key Identifier\n   *\n   * @example \"BB:AF:7E:02:3D:FA:A6:F1:3C:84:8E:AD:EE:38:98:EC:D9:32:32:D4\"\n   */\n  certIssuerSKI: string;\n  /**\n   * The certificate's SHA-1 fingerprint\n   *\n   * @example \"6b9109f323999e52259cda7373ff0b4d26bd232e\"\n   */\n  certFingerprintSHA1: string;\n  /**\n   * The certificate's SHA-256 fingerprint\n   *\n   * @example \"acf77cf37b4156a2708e34c4eb755f9b5dbbe5ebb55adfec8f11493438d19e6ad3f157f81fa3b98278453d5652b0c1fd1d71e5695ae4d709803a4d3f39de9dea\"\n   */\n  certFingerprintSHA256: string;\n  /**\n   * The effective starting date of the certificate\n   *\n   * @example \"Dec 22 19:39:00 2018 GMT\"\n   */\n  certNotBefore: string;\n  /**\n   * The effective expiration date of the certificate\n   *\n   * @example \"Dec 22 19:39:00 2018 GMT\"\n   */\n  certNotAfter: string;\n}\n/** Placeholder values for TLS Client Authorization */\nexport interface IncomingRequestCfPropertiesTLSClientAuthPlaceholder {\n  certPresented: \"0\";\n  certVerified: \"NONE\";\n  certRevoked: \"0\";\n  certIssuerDN: \"\";\n  certSubjectDN: \"\";\n  certIssuerDNRFC2253: \"\";\n  certSubjectDNRFC2253: \"\";\n  certIssuerDNLegacy: \"\";\n  certSubjectDNLegacy: \"\";\n  certSerial: \"\";\n  certIssuerSerial: \"\";\n  certSKI: \"\";\n  certIssuerSKI: \"\";\n  certFingerprintSHA1: \"\";\n  certFingerprintSHA256: \"\";\n  certNotBefore: \"\";\n  certNotAfter: \"\";\n}\n/** Possible outcomes of TLS verification */\nexport type CertVerificationStatus =\n  /** Authentication succeeded */\n  | \"SUCCESS\"\n  /** No certificate was presented */\n  | \"NONE\"\n  /** Failed because the certificate was self-signed */\n  | \"FAILED:self signed certificate\"\n  /** Failed because the certificate failed a trust chain check */\n  | \"FAILED:unable to verify the first certificate\"\n  /** Failed because the certificate not yet valid */\n  | \"FAILED:certificate is not yet valid\"\n  /** Failed because the certificate is expired */\n  | \"FAILED:certificate has expired\"\n  /** Failed for another unspecified reason */\n  | \"FAILED\";\n/**\n * An upstream endpoint's response to a TCP `keepalive` message from Cloudflare.\n */\nexport type IncomingRequestCfPropertiesEdgeRequestKeepAliveStatus =\n  | 0 /** Unknown */\n  | 1 /** no keepalives (not found) */\n  | 2 /** no connection re-use, opening keepalive connection failed */\n  | 3 /** no connection re-use, keepalive accepted and saved */\n  | 4 /** connection re-use, refused by the origin server (`TCP FIN`) */\n  | 5; /** connection re-use, accepted by the origin server */\n/** ISO 3166-1 Alpha-2 codes */\nexport type Iso3166Alpha2Code =\n  | \"AD\"\n  | \"AE\"\n  | \"AF\"\n  | \"AG\"\n  | \"AI\"\n  | \"AL\"\n  | \"AM\"\n  | \"AO\"\n  | \"AQ\"\n  | \"AR\"\n  | \"AS\"\n  | \"AT\"\n  | \"AU\"\n  | \"AW\"\n  | \"AX\"\n  | \"AZ\"\n  | \"BA\"\n  | \"BB\"\n  | \"BD\"\n  | \"BE\"\n  | \"BF\"\n  | \"BG\"\n  | \"BH\"\n  | \"BI\"\n  | \"BJ\"\n  | \"BL\"\n  | \"BM\"\n  | \"BN\"\n  | \"BO\"\n  | \"BQ\"\n  | \"BR\"\n  | \"BS\"\n  | \"BT\"\n  | \"BV\"\n  | \"BW\"\n  | \"BY\"\n  | \"BZ\"\n  | \"CA\"\n  | \"CC\"\n  | \"CD\"\n  | \"CF\"\n  | \"CG\"\n  | \"CH\"\n  | \"CI\"\n  | \"CK\"\n  | \"CL\"\n  | \"CM\"\n  | \"CN\"\n  | \"CO\"\n  | \"CR\"\n  | \"CU\"\n  | \"CV\"\n  | \"CW\"\n  | \"CX\"\n  | \"CY\"\n  | \"CZ\"\n  | \"DE\"\n  | \"DJ\"\n  | \"DK\"\n  | \"DM\"\n  | \"DO\"\n  | \"DZ\"\n  | \"EC\"\n  | \"EE\"\n  | \"EG\"\n  | \"EH\"\n  | \"ER\"\n  | \"ES\"\n  | \"ET\"\n  | \"FI\"\n  | \"FJ\"\n  | \"FK\"\n  | \"FM\"\n  | \"FO\"\n  | \"FR\"\n  | \"GA\"\n  | \"GB\"\n  | \"GD\"\n  | \"GE\"\n  | \"GF\"\n  | \"GG\"\n  | \"GH\"\n  | \"GI\"\n  | \"GL\"\n  | \"GM\"\n  | \"GN\"\n  | \"GP\"\n  | \"GQ\"\n  | \"GR\"\n  | \"GS\"\n  | \"GT\"\n  | \"GU\"\n  | \"GW\"\n  | \"GY\"\n  | \"HK\"\n  | \"HM\"\n  | \"HN\"\n  | \"HR\"\n  | \"HT\"\n  | \"HU\"\n  | \"ID\"\n  | \"IE\"\n  | \"IL\"\n  | \"IM\"\n  | \"IN\"\n  | \"IO\"\n  | \"IQ\"\n  | \"IR\"\n  | \"IS\"\n  | \"IT\"\n  | \"JE\"\n  | \"JM\"\n  | \"JO\"\n  | \"JP\"\n  | \"KE\"\n  | \"KG\"\n  | \"KH\"\n  | \"KI\"\n  | \"KM\"\n  | \"KN\"\n  | \"KP\"\n  | \"KR\"\n  | \"KW\"\n  | \"KY\"\n  | \"KZ\"\n  | \"LA\"\n  | \"LB\"\n  | \"LC\"\n  | \"LI\"\n  | \"LK\"\n  | \"LR\"\n  | \"LS\"\n  | \"LT\"\n  | \"LU\"\n  | \"LV\"\n  | \"LY\"\n  | \"MA\"\n  | \"MC\"\n  | \"MD\"\n  | \"ME\"\n  | \"MF\"\n  | \"MG\"\n  | \"MH\"\n  | \"MK\"\n  | \"ML\"\n  | \"MM\"\n  | \"MN\"\n  | \"MO\"\n  | \"MP\"\n  | \"MQ\"\n  | \"MR\"\n  | \"MS\"\n  | \"MT\"\n  | \"MU\"\n  | \"MV\"\n  | \"MW\"\n  | \"MX\"\n  | \"MY\"\n  | \"MZ\"\n  | \"NA\"\n  | \"NC\"\n  | \"NE\"\n  | \"NF\"\n  | \"NG\"\n  | \"NI\"\n  | \"NL\"\n  | \"NO\"\n  | \"NP\"\n  | \"NR\"\n  | \"NU\"\n  | \"NZ\"\n  | \"OM\"\n  | \"PA\"\n  | \"PE\"\n  | \"PF\"\n  | \"PG\"\n  | \"PH\"\n  | \"PK\"\n  | \"PL\"\n  | \"PM\"\n  | \"PN\"\n  | \"PR\"\n  | \"PS\"\n  | \"PT\"\n  | \"PW\"\n  | \"PY\"\n  | \"QA\"\n  | \"RE\"\n  | \"RO\"\n  | \"RS\"\n  | \"RU\"\n  | \"RW\"\n  | \"SA\"\n  | \"SB\"\n  | \"SC\"\n  | \"SD\"\n  | \"SE\"\n  | \"SG\"\n  | \"SH\"\n  | \"SI\"\n  | \"SJ\"\n  | \"SK\"\n  | \"SL\"\n  | \"SM\"\n  | \"SN\"\n  | \"SO\"\n  | \"SR\"\n  | \"SS\"\n  | \"ST\"\n  | \"SV\"\n  | \"SX\"\n  | \"SY\"\n  | \"SZ\"\n  | \"TC\"\n  | \"TD\"\n  | \"TF\"\n  | \"TG\"\n  | \"TH\"\n  | \"TJ\"\n  | \"TK\"\n  | \"TL\"\n  | \"TM\"\n  | \"TN\"\n  | \"TO\"\n  | \"TR\"\n  | \"TT\"\n  | \"TV\"\n  | \"TW\"\n  | \"TZ\"\n  | \"UA\"\n  | \"UG\"\n  | \"UM\"\n  | \"US\"\n  | \"UY\"\n  | \"UZ\"\n  | \"VA\"\n  | \"VC\"\n  | \"VE\"\n  | \"VG\"\n  | \"VI\"\n  | \"VN\"\n  | \"VU\"\n  | \"WF\"\n  | \"WS\"\n  | \"YE\"\n  | \"YT\"\n  | \"ZA\"\n  | \"ZM\"\n  | \"ZW\";\n/** The 2-letter continent codes Cloudflare uses */\nexport type ContinentCode = \"AF\" | \"AN\" | \"AS\" | \"EU\" | \"NA\" | \"OC\" | \"SA\";\nexport type CfProperties<HostMetadata = unknown> =\n  | IncomingRequestCfProperties<HostMetadata>\n  | RequestInitCfProperties;\nexport interface D1Meta {\n  duration: number;\n  size_after: number;\n  rows_read: number;\n  rows_written: number;\n  last_row_id: number;\n  changed_db: boolean;\n  changes: number;\n}\nexport interface D1Result<T = unknown> {\n  results: T[];\n  success: true;\n  meta: D1Meta & Record<string, unknown>;\n  error?: never;\n}\nexport interface D1ExecResult {\n  count: number;\n  duration: number;\n}\nexport declare abstract class D1Database {\n  prepare(query: string): D1PreparedStatement;\n  dump(): Promise<ArrayBuffer>;\n  batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;\n  exec(query: string): Promise<D1ExecResult>;\n}\nexport declare abstract class D1PreparedStatement {\n  bind(...values: unknown[]): D1PreparedStatement;\n  first<T = unknown>(colName: string): Promise<T | null>;\n  first<T = Record<string, unknown>>(): Promise<T | null>;\n  run<T = Record<string, unknown>>(): Promise<D1Result<T>>;\n  all<T = Record<string, unknown>>(): Promise<D1Result<T>>;\n  raw<T = unknown[]>(): Promise<T[]>;\n}\n/**\n * An email message that can be sent from a Worker.\n */\nexport interface EmailMessage {\n  /**\n   * Envelope From attribute of the email message.\n   */\n  readonly from: string;\n  /**\n   * Envelope To attribute of the email message.\n   */\n  readonly to: string;\n}\n/**\n * An email message that is sent to a consumer Worker and can be rejected/forwarded.\n */\nexport interface ForwardableEmailMessage extends EmailMessage {\n  /**\n   * Stream of the email message content.\n   */\n  readonly raw: ReadableStream<Uint8Array>;\n  /**\n   * An [Headers object](https://developer.mozilla.org/en-US/docs/Web/API/Headers).\n   */\n  readonly headers: Headers;\n  /**\n   * Size of the email message content.\n   */\n  readonly rawSize: number;\n  /**\n   * Reject this email message by returning a permanent SMTP error back to the connecting client including the given reason.\n   * @param reason The reject reason.\n   * @returns void\n   */\n  setReject(reason: string): void;\n  /**\n   * Forward this email message to a verified destination address of the account.\n   * @param rcptTo Verified destination address.\n   * @param headers A [Headers object](https://developer.mozilla.org/en-US/docs/Web/API/Headers).\n   * @returns A promise that resolves when the email message is forwarded.\n   */\n  forward(rcptTo: string, headers?: Headers): Promise<void>;\n}\n/**\n * A binding that allows a Worker to send email messages.\n */\nexport interface SendEmail {\n  send(message: EmailMessage): Promise<void>;\n}\nexport declare abstract class EmailEvent extends ExtendableEvent {\n  readonly message: ForwardableEmailMessage;\n}\nexport type EmailExportedHandler<Env = unknown> = (\n  message: ForwardableEmailMessage,\n  env: Env,\n  ctx: ExecutionContext\n) => void | Promise<void>;\nexport interface Hyperdrive {\n  /**\n   * Connect directly to Hyperdrive as if it's your database, returning a TCP socket.\n   *\n   * Calling this method returns an idential socket to if you call\n   * `connect(\"host:port\")` using the `host` and `port` fields from this object.\n   * Pick whichever approach works better with your preferred DB client library.\n   *\n   * Note that this socket is not yet authenticated -- it's expected that your\n   * code (or preferably, the client library of your choice) will authenticate\n   * using the information in this class's readonly fields.\n   */\n  connect(): Socket;\n  /**\n   * A valid DB connection string that can be passed straight into the typical\n   * client library/driver/ORM. This will typically be the easiest way to use\n   * Hyperdrive.\n   */\n  readonly connectionString: string;\n  /*\n   * A randomly generated hostname that is only valid within the context of the\n   * currently running Worker which, when passed into `connect()` function from\n   * the \"cloudflare:sockets\" module, will connect to the Hyperdrive instance\n   * for your database.\n   */\n  readonly host: string;\n  /*\n   * The port that must be paired the the host field when connecting.\n   */\n  readonly port: string;\n  /*\n   * The username to use when authenticating to your database via Hyperdrive.\n   * Unlike the host and password, this will be the same every time\n   */\n  readonly user: string;\n  /*\n   * The randomly generated password to use when authenticating to your\n   * database via Hyperdrive. Like the host field, this password is only valid\n   * within the context of the currently running Worker instance from which\n   * it's read.\n   */\n  readonly password: string;\n  /*\n   * The name of the database to connect to.\n   */\n  readonly database: string;\n}\nexport type Params<P extends string = any> = Record<P, string | string[]>;\nexport type EventContext<Env, P extends string, Data> = {\n  request: Request;\n  functionPath: string;\n  waitUntil: (promise: Promise<any>) => void;\n  passThroughOnException: () => void;\n  next: (input?: Request | string, init?: RequestInit) => Promise<Response>;\n  env: Env & {\n    ASSETS: {\n      fetch: typeof fetch;\n    };\n  };\n  params: Params<P>;\n  data: Data;\n};\nexport type PagesFunction<\n  Env = unknown,\n  Params extends string = any,\n  Data extends Record<string, unknown> = Record<string, unknown>\n> = (context: EventContext<Env, Params, Data>) => Response | Promise<Response>;\nexport type EventPluginContext<Env, P extends string, Data, PluginArgs> = {\n  request: Request;\n  functionPath: string;\n  waitUntil: (promise: Promise<any>) => void;\n  passThroughOnException: () => void;\n  next: (input?: Request | string, init?: RequestInit) => Promise<Response>;\n  env: Env & {\n    ASSETS: {\n      fetch: typeof fetch;\n    };\n  };\n  params: Params<P>;\n  data: Data;\n  pluginArgs: PluginArgs;\n};\nexport type PagesPluginFunction<\n  Env = unknown,\n  Params extends string = any,\n  Data extends Record<string, unknown> = Record<string, unknown>,\n  PluginArgs = unknown\n> = (\n  context: EventPluginContext<Env, Params, Data, PluginArgs>\n) => Response | Promise<Response>;\n// PubSubMessage represents an incoming PubSub message.\n// The message includes metadata about the broker, the client, and the payload\n// itself.\n// https://developers.cloudflare.com/pub-sub/\nexport interface PubSubMessage {\n  // Message ID\n  readonly mid: number;\n  // MQTT broker FQDN in the form mqtts://BROKER.NAMESPACE.cloudflarepubsub.com:PORT\n  readonly broker: string;\n  // The MQTT topic the message was sent on.\n  readonly topic: string;\n  // The client ID of the client that published this message.\n  readonly clientId: string;\n  // The unique identifier (JWT ID) used by the client to authenticate, if token\n  // auth was used.\n  readonly jti?: string;\n  // A Unix timestamp (seconds from Jan 1, 1970), set when the Pub/Sub Broker\n  // received the message from the client.\n  readonly receivedAt: number;\n  // An (optional) string with the MIME type of the payload, if set by the\n  // client.\n  readonly contentType: string;\n  // Set to 1 when the payload is a UTF-8 string\n  // https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901063\n  readonly payloadFormatIndicator: number;\n  // Pub/Sub (MQTT) payloads can be UTF-8 strings, or byte arrays.\n  // You can use payloadFormatIndicator to inspect this before decoding.\n  payload: string | Uint8Array;\n}\n// JsonWebKey extended by kid parameter\nexport interface JsonWebKeyWithKid extends JsonWebKey {\n  // Key Identifier of the JWK\n  readonly kid: string;\n}\n// Copyright (c) 2022-2023 Cloudflare, Inc.\n// Licensed under the Apache 2.0 license found in the LICENSE file or at:\n//     https://opensource.org/licenses/Apache-2.0\n/**\n * Data types supported for holding vector metadata.\n */\nexport type VectorizeVectorMetadataValue = string | number | boolean | string[];\n/**\n * Additional information to associate with a vector.\n */\nexport type VectorizeVectorMetadata =\n  | VectorizeVectorMetadataValue\n  | Record<string, VectorizeVectorMetadataValue>;\nexport type VectorFloatArray = Float32Array | Float64Array;\nexport interface VectorizeError {\n  code?: number;\n  error: string;\n}\n/**\n * Comparison logic/operation to use for metadata filtering.\n *\n * This list is expected to grow as support for more operations are released.\n */\nexport type VectorizeVectorMetadataFilterOp = \"$eq\" | \"$ne\";\n/**\n * Filter criteria for vector metadata used to limit the retrieved query result set.\n */\nexport type VectorizeVectorMetadataFilter = {\n  [field: string]:\n    | Exclude<VectorizeVectorMetadataValue, string[]>\n    | null\n    | {\n        [Op in VectorizeVectorMetadataFilterOp]?: Exclude<\n          VectorizeVectorMetadataValue,\n          string[]\n        > | null;\n      };\n};\n/**\n * Supported distance metrics for an index.\n * Distance metrics determine how other \"similar\" vectors are determined.\n */\nexport type VectorizeDistanceMetric = \"euclidean\" | \"cosine\" | \"dot-product\";\nexport interface VectorizeQueryOptions {\n  topK?: number;\n  namespace?: string;\n  returnValues?: boolean;\n  returnMetadata?: boolean;\n  filter?: VectorizeVectorMetadataFilter;\n}\n/**\n * Information about the configuration of an index.\n */\nexport type VectorizeIndexConfig =\n  | {\n      dimensions: number;\n      metric: VectorizeDistanceMetric;\n    }\n  | {\n      preset: string; // keep this generic, as we'll be adding more presets in the future and this is only in a read capacity\n    };\n/**\n * Metadata about an existing index.\n */\nexport interface VectorizeIndexDetails {\n  /** The unique ID of the index */\n  readonly id: string;\n  /** The name of the index. */\n  name: string;\n  /** (optional) A human readable description for the index. */\n  description?: string;\n  /** The index configuration, including the dimension size and distance metric. */\n  config: VectorizeIndexConfig;\n  /** The number of records containing vectors within the index. */\n  vectorsCount: number;\n}\n/**\n * Represents a single vector value set along with its associated metadata.\n */\nexport interface VectorizeVector {\n  /** The ID for the vector. This can be user-defined, and must be unique. It should uniquely identify the object, and is best set based on the ID of what the vector represents. */\n  id: string;\n  /** The vector values */\n  values: VectorFloatArray | number[];\n  /** The namespace this vector belongs to. */\n  namespace?: string;\n  /** Metadata associated with the vector. Includes the values of the other fields and potentially additional details. */\n  metadata?: Record<string, VectorizeVectorMetadata>;\n}\n/**\n * Represents a matched vector for a query along with its score and (if specified) the matching vector information.\n */\nexport type VectorizeMatch = Pick<Partial<VectorizeVector>, \"values\"> &\n  Omit<VectorizeVector, \"values\"> & {\n    /** The score or rank for similarity, when returned as a result */\n    score: number;\n  };\n/**\n * A set of vector {@link VectorizeMatch} for a particular query.\n */\nexport interface VectorizeMatches {\n  matches: VectorizeMatch[];\n  count: number;\n}\n/**\n * Results of an operation that performed a mutation on a set of vectors.\n * Here, `ids` is a list of vectors that were successfully processed.\n */\nexport interface VectorizeVectorMutation {\n  /* List of ids of vectors that were successfully processed. */\n  ids: string[];\n  /* Total count of the number of processed vectors. */\n  count: number;\n}\nexport declare abstract class VectorizeIndex {\n  /**\n   * Get information about the currently bound index.\n   * @returns A promise that resolves with information about the current index.\n   */\n  public describe(): Promise<VectorizeIndexDetails>;\n  /**\n   * Use the provided vector to perform a similarity search across the index.\n   * @param vector Input vector that will be used to drive the similarity search.\n   * @param options Configuration options to massage the returned data.\n   * @returns A promise that resolves with matched and scored vectors.\n   */\n  public query(\n    vector: VectorFloatArray | number[],\n    options: VectorizeQueryOptions\n  ): Promise<VectorizeMatches>;\n  /**\n   * Insert a list of vectors into the index dataset. If a provided id exists, an error will be thrown.\n   * @param vectors List of vectors that will be inserted.\n   * @returns A promise that resolves with the ids & count of records that were successfully processed.\n   */\n  public insert(vectors: VectorizeVector[]): Promise<VectorizeVectorMutation>;\n  /**\n   * Upsert a list of vectors into the index dataset. If a provided id exists, it will be replaced with the new values.\n   * @param vectors List of vectors that will be upserted.\n   * @returns A promise that resolves with the ids & count of records that were successfully processed.\n   */\n  public upsert(vectors: VectorizeVector[]): Promise<VectorizeVectorMutation>;\n  /**\n   * Delete a list of vectors with a matching id.\n   * @param ids List of vector ids that should be deleted.\n   * @returns A promise that resolves with the ids & count of records that were successfully processed (and thus deleted).\n   */\n  public deleteByIds(ids: string[]): Promise<VectorizeVectorMutation>;\n  /**\n   * Get a list of vectors with a matching id.\n   * @param ids List of vector ids that should be returned.\n   * @returns A promise that resolves with the raw unscored vectors matching the id set.\n   */\n  public getByIds(ids: string[]): Promise<VectorizeVector[]>;\n}\nexport interface DynamicDispatchLimits {\n  /**\n   * Limit CPU time in milliseconds.\n   */\n  cpuMs?: number;\n  /**\n   * Limit number of subrequests.\n   */\n  subRequests?: number;\n}\nexport interface DynamicDispatchOptions {\n  /**\n   * Limit resources of invoked Worker script.\n   */\n  limits?: DynamicDispatchLimits;\n  /**\n   * Arguments for outbound Worker script, if configured.\n   */\n  outbound?: {\n    [key: string]: any;\n  };\n}\nexport interface DispatchNamespace {\n  /**\n   * @param name Name of the Worker script.\n   * @param args Arguments to Worker script.\n   * @param options Options for Dynamic Dispatch invocation.\n   * @returns A Fetcher object that allows you to send requests to the Worker script.\n   * @throws If the Worker script does not exist in this dispatch namespace, an error will be thrown.\n   */\n  get(\n    name: string,\n    args?: {\n      [key: string]: any;\n    },\n    options?: DynamicDispatchOptions\n  ): Fetcher;\n}\n", "var r=async(...e)=>t.redirect(e[0]??\"\",e[1]??302);const{Response:t}=await import(\"@cloudflare/workers-types/experimental/index.js\");export{t as Response,r as default};\n", "var t=async(...e)=>new s(JSON.stringify(e[0]),{status:e[1]??200,headers:{\"Content-Type\":\"application/json;charset=utf-8\"}});const{Response:s}=await import(\"@cloudflare/workers-types/experimental/index.js\");export{s as Response,t as default};\n", "// // This loads all middlewares exposed on the middleware object\n// // and then starts the invocation chain.\n// // The big idea is that we can add these to the middleware export dynamically\n// // through wrangler, or we can potentially let users directly add them as a sort\n// // of \"plugin\" system.\n\nimport worker from \"D:\\\\Developer\\\\Application\\\\CodeEditorLand\\\\Environment\\\\NPM\\\\Ingress\\\\.wrangler\\\\tmp\\\\bundle-UerOvD\\\\middleware-insertion-facade.js\";\nimport {\n\t__facade_invoke__,\n\t__facade_register__,\n\tDispatcher,\n\tMiddleware,\n} from \"D:\\\\tools\\\\.pnpm-global\\\\5\\\\node_modules\\\\.pnpm\\\\wrangler@3.25.0\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\n\n// We need to preserve all of the exports from the worker\nexport * from \"D:\\\\Developer\\\\Application\\\\CodeEditorLand\\\\Environment\\\\NPM\\\\Ingress\\\\.wrangler\\\\tmp\\\\bundle-UerOvD\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\t#noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nconst __facade_modules_fetch__: ExportedHandlerFetchHandler = function (\n\trequest,\n\tenv,\n\tctx\n) {\n\tif (worker.fetch === undefined)\n\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\treturn worker.fetch(request, env, ctx);\n};\n\nfunction getMaskedEnv(rawEnv: unknown) {\n\tlet env = rawEnv as Record<string, unknown>;\n\tif (worker.envWrappers && worker.envWrappers.length > 0) {\n\t\tfor (const wrapFn of worker.envWrappers) {\n\t\t\tenv = wrapFn(env);\n\t\t}\n\t}\n\treturn env;\n}\n\n/**\n * This type is here to cause a type error if a new export handler is added to\n * `ExportHandler` without it being included in the `facade` below.\n */\ntype MissingExportHandlers = Omit<\n\tRequired<ExportedHandler>,\n\t\"tail\" | \"trace\" | \"scheduled\" | \"queue\" | \"test\" | \"email\" | \"fetch\"\n>;\n\nlet registeredMiddleware = false;\n\nconst facade: ExportedHandler<unknown> & MissingExportHandlers = {\n\t...(worker.tail && {\n\t\ttail: maskHandlerEnv(worker.tail),\n\t}),\n\t...(worker.trace && {\n\t\ttrace: maskHandlerEnv(worker.trace),\n\t}),\n\t...(worker.scheduled && {\n\t\tscheduled: maskHandlerEnv(worker.scheduled),\n\t}),\n\t...(worker.queue && {\n\t\tqueue: maskHandlerEnv(worker.queue),\n\t}),\n\t...(worker.test && {\n\t\ttest: maskHandlerEnv(worker.test),\n\t}),\n\t...(worker.email && {\n\t\temail: maskHandlerEnv(worker.email),\n\t}),\n\n\tfetch(request, rawEnv, ctx) {\n\t\tconst env = getMaskedEnv(rawEnv);\n\t\t// Get the chain of middleware from the worker object\n\t\tif (worker.middleware && worker.middleware.length > 0) {\n\t\t\t// Make sure we only register middleware once:\n\t\t\t// https://github.com/cloudflare/workers-sdk/issues/2386#issuecomment-1614715911\n\t\t\tif (!registeredMiddleware) {\n\t\t\t\tregisteredMiddleware = true;\n\t\t\t\tfor (const middleware of worker.middleware) {\n\t\t\t\t\t__facade_register__(middleware);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst __facade_modules_dispatch__: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tenv,\n\t\t\t\tctx,\n\t\t\t\t__facade_modules_dispatch__,\n\t\t\t\t__facade_modules_fetch__\n\t\t\t);\n\t\t} else {\n\t\t\t// We didn't have any middleware so we can skip the invocation chain,\n\t\t\t// and just call the fetch handler directly\n\n\t\t\t// We \"don't care\" if this is undefined as we want to have the same behavior\n\t\t\t// as if the worker completely bypassed middleware.\n\t\t\treturn __facade_modules_fetch__(request, env, ctx);\n\t\t}\n\t},\n};\n\ntype HandlerFn<D, R> = (data: D, env: unknown, ctx: ExecutionContext) => R;\nfunction maskHandlerEnv<D, R>(handler: HandlerFn<D, R>): HandlerFn<D, R> {\n\treturn (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);\n}\n\nexport default facade;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"D:\\\\Developer\\\\Application\\\\CodeEditorLand\\\\Environment\\\\NPM\\\\Ingress\\\\Target\\\\Variable\\\\Worker.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"D:\\\\tools\\\\.pnpm-global\\\\5\\\\node_modules\\\\.pnpm\\\\wrangler@3.25.0\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\t\t\t\tconst envWrappers = [__MIDDLEWARE_0__.wrap].filter(Boolean);\n\t\t\t\tconst facade = {\n\t\t\t\t\t...worker,\n\t\t\t\t\tenvWrappers,\n\t\t\t\t\tmiddleware: [\n\t\t\t\t\t\t__MIDDLEWARE_0__.default,\n            ...(worker.middleware ? worker.middleware : []),\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t}\n\t\t\t\texport * from \"D:\\\\Developer\\\\Application\\\\CodeEditorLand\\\\Environment\\\\NPM\\\\Ingress\\\\Target\\\\Variable\\\\Worker.js\";\n\n\t\t\t\tconst maskDurableObjectDefinition = (cls) =>\n\t\t\t\t\tclass extends cls {\n\t\t\t\t\t\tconstructor(state, env) {\n\t\t\t\t\t\t\tlet wrappedEnv = env\n\t\t\t\t\t\t\tfor (const wrapFn of envWrappers) {\n\t\t\t\t\t\t\t\twrappedEnv = wrapFn(wrappedEnv)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuper(state, wrappedEnv);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\n\n\t\t\t\texport default facade;", "var r={fetch:async(...[t,e])=>await(await import(\"itty-router/Router\")).Router().get(\"*\",async()=>await a({Error:\"Not Found.\"},404)).handle(t,e)};const{default:o}=await import(\"@codeeditorland/common/Target/Function/Redirect.js\"),{default:a}=await import(\"@codeeditorland/common/Target/Function/Response.js\");export{o as Redirect,a as Response,r as default};\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\nexport const wrap = undefined;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": ";;;;;;;;;;;AAEA,SAAS,SAAS,SAAS,MAAM;AAChC,QAAM,MACL,mBAAmB,MAChB,UACA,IAAI;AAAA,KACH,OAAO,YAAY,WACjB,IAAI,QAAQ,SAAS,IAAI,IACzB,SACD;AAAA,EACF;AACJ,MAAI,IAAI,QAAQ,IAAI,SAAS,SAAS,IAAI,aAAa,UAAU;AAChE,QAAI,CAAC,KAAK,IAAI,IAAI,SAAS,CAAC,GAAG;AAC9B,WAAK,IAAI,IAAI,SAAS,CAAC;AACvB,cAAQ;AAAA,QACP;AAAA,KACO,IAAI,SAAS;AAAA;AAAA,MACrB;AAAA,IACD;AAAA,EACD;AACD;AArBA,IAAM;AAAN;AAAA;AAAA;AAAA,IAAM,OAAO,oBAAI,IAAI;AAuBrB,eAAW,QAAQ,IAAI,MAAM,WAAW,OAAO;AAAA,MAC9C,MAAM,QAAQ,SAAS,UAAU;AAChC,cAAM,CAAC,SAAS,IAAI,IAAI;AACxB,iBAAS,SAAS,IAAI;AACtB,eAAO,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAAA,MAC/C;AAAA,IACD,CAAC;AAAA;AAAA;;;AC7BD;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAGA;AAAA;AAAA;;;ACwEa;;;;IAAAA;AAAA;;;;IAAAA,IAAS,CAAA,EAIlBC,MAAAA,KAAO,IAAIC,QAAAA,KAAS,CAAA,GAAA,GAAOC,GAAAA,IAAyB,CAAE,OAExD,EACEC,WAAW,IAAIC,MAAM,CAAA,GAAI,EAEvBC,KAAK,CAACC,IAAaC,IAAcC,IAAsBC,MAC7C,YAARF,KAAmBC,GAASE,QAE5B,CAACC,OAAkBC,MACjBX,GAAOY,KACL,CACEN,GAAKO,cAAAA,GACLC,OAAO,KAAKN,KAAQT,KAAOW,IACxBK,QAAQ,cAAc,IAAA,GACtBA,QAAQ,qBAAqB,cAAA,EAC7BA,QAAQ,mBAAmB,qBAAA,EAC3BA,QAAQ,OAAO,KAAA,EACfA,QAAQ,YAAY,SAAA,MAAA,GAEvBJ,GACAH,CAAAA,CAAAA,KAECD,GAAAA,CAAAA,GAEXP,QAAAA,IAAAA,GACGC,IACHe,MAAAA,MAAaC,OAAyBC,IAAAA;AACpC,UAAIC,IAAUC,IAAOC,IAAM,IAAIC,IAAIL,GAAQI,GAAAA,GAAME,IAA6BN,GAAQM,QAAQ,EAAErB,WAAW,KAAA;AAG3G,eAAK,CAAKsB,IAAGC,EAAAA,KAAMJ,EAAIK;AACrBH,UAAMC,EAAAA,IAAKD,EAAMC,EAAAA,IAAM,CAAA,EAAgBG,OAAOJ,EAAMC,EAAAA,GAAIC,EAAAA,IAAKA;AAG/D,eAAK,CAAKG,IAAQC,GAAOlB,IAAUH,CAAAA,KAASR;AAC1C,aAAK4B,MAAUX,GAAQW,UAAoB,SAAVA,QAAqBR,KAAQC,EAAIS,SAASV,MAAMS,CAAAA,IAAS;AACxFZ,UAAAA,GAAQc,SAASX,GAAMY,UAAU,CAAA,GACjCf,GAAQP,QAAQF;AAChB,mBAASyB,MAAWtB;AAClB,gBAAqE,SAAhEQ,KAAAA,MAAiBc,GAAQhB,GAAQiB,SAASjB,IAAAA,GAAYC,EAAAA;AAAgB,qBAAOC;QACrF;IACJ,EAAA;;;;;ACxHL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAI,GAA6D;AAAjE;AAAA;AAAA;AAAA;AAAA,IAAI,IAAE,UAASgB,OAAI,EAAE,SAASA,GAAE,CAAC,KAAG,IAAGA,GAAE,CAAC,KAAG,GAAG;AAAE,KAAK,EAAC,UAAS,MAAG,MAAM;AAAA;AAAA;;;ACA1E;AAAA;AAAA;AAAA,iBAAAC;AAAA;AAAA,IAAIA,IAAuI;AAA3I;AAAA;AAAA;AAAA;AAAA,IAAIA,KAAE,UAASC,OAAI,IAAI,EAAE,KAAK,UAAUA,GAAE,CAAC,CAAC,GAAE,EAAC,QAAOA,GAAE,CAAC,KAAG,KAAI,SAAQ,EAAC,gBAAe,iCAAgC,EAAC,CAAC;AAAE,KAAK,EAAC,UAAS,MAAG,MAAM;AAAA;AAAA;;;ACApJ;AAAA;;;ACAA;AAAA;;;ACAA;AAAA;AAAA,IAAIC,KAAE,EAAC,OAAM,UAAS,CAACC,IAAEC,EAAC,MAAI,OAAM,MAAM,+DAA8B,OAAO,EAAE,IAAI,KAAI,YAAS,MAAM,EAAE,EAAC,OAAM,aAAY,GAAE,GAAG,CAAC,EAAE,OAAOD,IAAEC,EAAC,EAAC;AAAE,IAAK,EAAC,SAAQ,EAAC,IAAE,MAAM;AAAvB,IAAoF,EAAC,SAAQ,EAAC,IAAE,MAAM;;;ACAxP;AAAA;AASA,SAAS,YAAYC,IAAmB;AACvC,SAAO;AAAA,IACN,MAAMA,IAAG;AAAA,IACT,SAASA,IAAG,WAAW,OAAOA,EAAC;AAAA,IAC/B,OAAOA,IAAG;AAAA,IACV,OAAOA,IAAG,UAAU,SAAY,SAAY,YAAYA,GAAE,KAAK;AAAA,EAChE;AACD;AAGA,IAAM,YAAwB,OAAO,SAAS,KAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAAS,GAAG;AAAA,EAC7C,SAASA,IAAP;AACD,UAAM,QAAQ,YAAYA,EAAC;AAC3B,WAAO,SAAS,KAAK,OAAO;AAAA,MAC3B,QAAQ;AAAA,MACR,SAAS,EAAE,+BAA+B,OAAO;AAAA,IAClD,CAAC;AAAA,EACF;AACD;AAEA,IAAO,2CAAQ;AACR,IAAM,OAAO;;;AF9BhB,IAAM,cAAc,CAAkB,IAAI,EAAE,OAAO,OAAO;AAC1D,IAAM,SAAS;AAAA,EACd,GAAGC;AAAA,EACH;AAAA,EACA,YAAY;AAAA,IACM;AAAA,IACX,GAAIA,GAAO,aAAaA,GAAO,aAAa,CAAC;AAAA,EACpD,EAAE,OAAO,OAAO;AACjB;AAeA,IAAO,sCAAQ;;;AGzBnB;AAAA;AAwBA,IAAM,wBAAsC,CAAC;AAKtC,SAAS,uBAAuB,MAAqC;AAC3E,wBAAsB,KAAK,GAAG,KAAK,KAAK,CAAC;AAC1C;AAOA,SAAS,uBACR,SACA,KACA,KACA,UACA,iBACsB;AACtB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI;AACxB,QAAM,gBAAmC;AAAA,IACxC;AAAA,IACA,KAAK,YAAY,QAAQ;AACxB,aAAO,uBAAuB,YAAY,QAAQ,KAAK,UAAU,IAAI;AAAA,IACtE;AAAA,EACD;AACA,SAAO,KAAK,SAAS,KAAK,KAAK,aAAa;AAC7C;AAEO,SAAS,kBACf,SACA,KACA,KACA,UACA,iBACsB;AACtB,SAAO,uBAAuB,SAAS,KAAK,KAAK,UAAU;AAAA,IAC1D,GAAG;AAAA,IACH;AAAA,EACD,CAAC;AACF;;;AJjDA,IAAM,iCAAN,MAAoE;AAAA,EAGnE,YACU,eACA,MACT,SACC;AAHQ;AACA;AAGT,SAAK,WAAW;AAAA,EACjB;AAAA,EARA;AAAA,EAUA,UAAU;AACT,QAAI,EAAE,gBAAgB,iCAAiC;AACtD,YAAM,IAAI,UAAU,oBAAoB;AAAA,IACzC;AAEA,SAAK,SAAS;AAAA,EACf;AACD;AAEA,IAAM,2BAAwD,SAC7D,SACA,KACA,KACC;AACD,MAAI,oCAAO,UAAU;AACpB,UAAM,IAAI,MAAM,6CAA6C;AAC9D,SAAO,oCAAO,MAAM,SAAS,KAAK,GAAG;AACtC;AAEA,SAAS,aAAa,QAAiB;AACtC,MAAI,MAAM;AACV,MAAI,oCAAO,eAAe,oCAAO,YAAY,SAAS,GAAG;AACxD,eAAW,UAAU,oCAAO,aAAa;AACxC,YAAM,OAAO,GAAG;AAAA,IACjB;AAAA,EACD;AACA,SAAO;AACR;AAWA,IAAI,uBAAuB;AAE3B,IAAMC,UAA2D;AAAA,EAChE,GAAI,oCAAO,QAAQ;AAAA,IAClB,MAAM,eAAe,oCAAO,IAAI;AAAA,EACjC;AAAA,EACA,GAAI,oCAAO,SAAS;AAAA,IACnB,OAAO,eAAe,oCAAO,KAAK;AAAA,EACnC;AAAA,EACA,GAAI,oCAAO,aAAa;AAAA,IACvB,WAAW,eAAe,oCAAO,SAAS;AAAA,EAC3C;AAAA,EACA,GAAI,oCAAO,SAAS;AAAA,IACnB,OAAO,eAAe,oCAAO,KAAK;AAAA,EACnC;AAAA,EACA,GAAI,oCAAO,QAAQ;AAAA,IAClB,MAAM,eAAe,oCAAO,IAAI;AAAA,EACjC;AAAA,EACA,GAAI,oCAAO,SAAS;AAAA,IACnB,OAAO,eAAe,oCAAO,KAAK;AAAA,EACnC;AAAA,EAEA,MAAM,SAAS,QAAQ,KAAK;AAC3B,UAAM,MAAM,aAAa,MAAM;AAE/B,QAAI,oCAAO,cAAc,oCAAO,WAAW,SAAS,GAAG;AAGtD,UAAI,CAAC,sBAAsB;AAC1B,+BAAuB;AACvB,mBAAW,cAAc,oCAAO,YAAY;AAC3C,8BAAoB,UAAU;AAAA,QAC/B;AAAA,MACD;AAEA,YAAM,8BAA0C,SAAU,MAAM,MAAM;AACrE,YAAI,SAAS,eAAe,oCAAO,cAAc,QAAW;AAC3D,gBAAM,aAAa,IAAI;AAAA,YACtB,KAAK,IAAI;AAAA,YACT,KAAK,QAAQ;AAAA,YACb,MAAM;AAAA,YAAC;AAAA,UACR;AACA,iBAAO,oCAAO,UAAU,YAAY,KAAK,GAAG;AAAA,QAC7C;AAAA,MACD;AAEA,aAAO;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAAA,IACD,OAAO;AAMN,aAAO,yBAAyB,SAAS,KAAK,GAAG;AAAA,IAClD;AAAA,EACD;AACD;AAGA,SAAS,eAAqB,SAA2C;AACxE,SAAO,CAAC,MAAM,KAAK,QAAQ,QAAQ,MAAM,aAAa,GAAG,GAAG,GAAG;AAChE;AAEA,IAAO,kCAAQA;",
  "names": ["Router", "base", "routes", "other", "__proto__", "Proxy", "get", "target", "prop", "receiver", "path", "fetch", "route", "handlers", "push", "toUpperCase", "RegExp", "replace", "async", "request", "args", "response", "match", "url", "URL", "query", "k", "v", "searchParams", "concat", "method", "regex", "pathname", "params", "groups", "handler", "proxy", "e", "t", "e", "r", "t", "e", "e", "r", "facade"]
}
